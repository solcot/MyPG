import sys
import requests
from requests.exceptions import ConnectTimeout, ReadTimeout, Timeout, ConnectionError
import json
import time
import yaml
import random
import math
import pandas as pd
from io import BytesIO
from datetime import datetime, timedelta
from holidayskr import is_holiday
import configparser # ì¶”ê°€
import os # íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ ë° ì‚­ì œë¥¼ ìœ„í•´ os ëª¨ë“ˆ ì¶”ê°€
import psycopg2
from psycopg2.extras import execute_batch

with open('C:\\StockPy_dp\\config.yaml', encoding='UTF-8') as f:
    _cfg = yaml.load(f, Loader=yaml.FullLoader)
APP_KEY = _cfg['APP_KEY']
APP_SECRET = _cfg['APP_SECRET']
ACCESS_TOKEN = ""
CANO = _cfg['CANO']
ACNT_PRDT_CD = _cfg['ACNT_PRDT_CD']
DISCORD_WEBHOOK_URL = _cfg['DISCORD_WEBHOOK_URL']
DISCORD_WEBHOOK_URL_MAIN = _cfg['DISCORD_WEBHOOK_URL_MAIN']
URL_BASE = _cfg['URL_BASE']
HOST = _cfg['HOST']
DBNAME = _cfg['DBNAME']
USER = _cfg['USER']
PASSWORD = _cfg['PASSWORD']

# SettingReload.ini íŒŒì¼ì„ ìœ„í•œ ConfigParser ê°ì²´ ì „ì—­ ì„ ì–¸ (ë˜ëŠ” í•¨ìˆ˜ ë°”ê¹¥)
RELOAD_CONFIG_PATH = 'C:\\StockPy_dp\\SettingReload.ini'
RELOAD_CONFIG = configparser.ConfigParser()

def send_message(msg):
    """ë””ìŠ¤ì½”ë“œ ë©”ì„¸ì§€ ì „ì†¡"""
    now = datetime.now()
    message = {"content": f"[{now.strftime('%Y-%m-%d %H:%M:%S')}] {str(msg)}"}
    try:
        requests.post(DISCORD_WEBHOOK_URL, data=message, timeout=5)
    except Exception as e:
        print(f"âŒ Discord ì „ì†¡ ì‹¤íŒ¨: {e}", flush=True)
    print(message, flush=True)

def send_message_main(msg):
    """ë””ìŠ¤ì½”ë“œ ë©”ì„¸ì§€ ì „ì†¡"""
    now = datetime.now()
    message = {"content": f"[{now.strftime('%Y-%m-%d %H:%M:%S')}] {str(msg)}"}
    try:
        requests.post(DISCORD_WEBHOOK_URL_MAIN, data=message, timeout=5)
    except Exception as e:
        print(f"âŒ Discord ì „ì†¡ ì‹¤íŒ¨: {e}", flush=True)
    #print(message, flush=True)

def get_access_token():
    """í† í° ë°œê¸‰"""
    headers = {"content-type":"application/json"}
    body = {"grant_type":"client_credentials",
    "appkey":APP_KEY, 
    "appsecret":APP_SECRET}
    PATH = "oauth2/tokenP"
    URL = f"{URL_BASE}/{PATH}"
    res = requests.post(URL, headers=headers, data=json.dumps(body))
    ACCESS_TOKEN = res.json()["access_token"]
    return ACCESS_TOKEN
    
def hashkey(datas):
    """ì•”í˜¸í™”"""
    PATH = "uapi/hashkey"
    URL = f"{URL_BASE}/{PATH}"
    headers = {
    'content-Type' : 'application/json',
    'appKey' : APP_KEY,
    'appSecret' : APP_SECRET,
    }
    res = requests.post(URL, headers=headers, data=json.dumps(datas))
    hashkey = res.json()["HASH"]
    return hashkey

def get_last_trading_day():
    day = datetime.today() - timedelta(days=1)
    while day.weekday() >= 5 or is_holiday(day.strftime("%Y-%m-%d")):
        day -= timedelta(days=1)
    return day.strftime('%Y%m%d')

def fetch_krx_data(mktId, trade_date):
    otp_url = 'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
    otp_form_data = {
        'locale': 'ko_KR',
        'name': 'fileDown',
        'url': 'dbms/MDC/STAT/standard/MDCSTAT01501',  # ì´ ë¶€ë¶„ì´ í•µì‹¬
        'mktId': mktId,            # 'STK', 'KSQ'
        'trdDd': trade_date,
        'money': '1',              # ì› ë‹¨ìœ„
        'csvxls_isNo': 'false'
    }
    headers = {
        'Referer': 'http://data.krx.co.kr/contents/MDC/MDI/mdiLoader',
        'User-Agent': 'Mozilla/5.0'
    }

    #send_message(f"OTP ì½”ë“œ ìƒì„± ìš”ì²­ ì¤‘... ì‹œì¥: {mktId}, ë‚ ì§œ: {trade_date}")
    otp_response = requests.post(otp_url, data=otp_form_data, headers=headers)
    if otp_response.status_code != 200:
        send_message(f"OTP ìš”ì²­ ì‹¤íŒ¨: ìƒíƒœ ì½”ë“œ {otp_response.status_code}")
        send_message(otp_response.text)
        return None
    otp_code = otp_response.text

    #send_message(f"CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘... ì‹œì¥: {mktId}")
    csv_url = 'http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd'
    csv_response = requests.post(csv_url, data={'code': otp_code}, headers=headers)
    if csv_response.status_code != 200:
        send_message(f"CSV ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ìƒíƒœ ì½”ë“œ {csv_response.status_code}")
        send_message(csv_response.text)
        return None

    try:
        df = pd.read_csv(BytesIO(csv_response.content), encoding='euc-kr')
        return df
    except Exception as e:
        send_message(f"CSV íŒŒì‹± ì˜¤ë¥˜: {e}")
        return None

def get_db_connection():
    """ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ê°ì²´ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜"""
    return psycopg2.connect(
        host=HOST,
        dbname=DBNAME,
        user=USER,
        password=PASSWORD
    )

def get_all_symbols(p_trade_date='20250901', p_max_price=500000, p_pool_count=13):
    trade_date = p_trade_date

    # PostgreSQL ì ‘ì† í›„ ì¿¼ë¦¬ ì‹¤í–‰
    try:
        with get_db_connection() as conn:
            with conn.cursor() as cur:
                sql = """
                    select * from get_stock_dp01(%s, %s, %s);
                """
                cur.execute(sql, (trade_date,p_max_price,p_pool_count))
                rows = cur.fetchall()

                symbols_name_dict = {str(code).zfill(6): name for code, name in rows}

        #send_message(f"âœ… [{trade_date}]ì¼ DB ì¡°íšŒ ì™„ë£Œ: {len(symbols_name_dict)}ê±´ ë³€ë™ì„±ëŒíŒŒ ë§¤ìˆ˜í’€ ë°˜í™˜")
        #send_message_main(f"âœ… [{trade_date}]ì¼ DB ì¡°íšŒ ì™„ë£Œ: {len(symbols_name_dict)}ê±´ ë³€ë™ì„±ëŒíŒŒ ë§¤ìˆ˜í’€ ë°˜í™˜")")
        #send_message(symbols_name_dict)
        #send_message_main(symbols_name_dict)
        return symbols_name_dict

    except Exception as e:
        send_message(f"âŒ DB ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return {}

# --- âœ¨ ì†ì ˆ (Trailing Stop) ë¡œì§ í•¨ìˆ˜ âœ¨ ---
def check_trailing_stop_loss(
    stock_dict, 
    trailing_losses, 
    blocked_symbols,   # ğŸš¨ ì¶”ê°€: ë¬¼íƒ€ê¸° ì œí•œì— ê±¸ë¦° ì¢…ëª© ê´€ë¦¬ìš© set
    stop_loss_threshold=-7.0, 
    trailing_rebound=1.0, 
    stop_abs_loss_threshold=-15.0, 
    add_lose_pct=-5.0, 
    max_mooling=5
):
    """
    ì†ì ˆ ê°ì‹œ (ë¬¼íƒ€ê¸° ì ìš©):
    1. ì§€ì†ì ì¸ í•˜ë½ ì¤‘ -5% ì´ˆê³¼ ì‹œ ë¬´ì¡°ê±´ ì†ì ˆ (í˜„ì¬ ë¹„í™œì„±í™”ë¨)
    2. ì†ì‹¤ì´ ì¤„ì—ˆë‹¤ê°€ ë‹¤ì‹œ ì•…í™”ë˜ë©´ íŠ¸ë ˆì¼ë§ ì†ì ˆ ëŒ€ì‹  ë¬¼íƒ€ê¸° ì‹ í˜¸
    3. ë¬¼íƒ€ê¸° íšŸìˆ˜ ì œí•œ (max_mooling, ê¸°ë³¸ 5íšŒ)
       â†’ ì œí•œ ë„ë‹¬ ì‹œ ğŸš« ë©”ì‹œì§€ëŠ” ë”± 1ë²ˆë§Œ ì¶œë ¥
    """
    stopped = []

    for sym, info in stock_dict.items():
        current_price = get_current_price(sym)
        bought_price = info.get("ë§¤ìˆ˜ê°€")
        # âœ… ë°©ì–´ ì½”ë“œ ì¶”ê°€
        if current_price is None or bought_price is None or bought_price == 0:
            send_message(f"âš ï¸ [check_trailing_stop_loss] {info.get('ì¢…ëª©ëª…')}({sym}) ë§¤ìˆ˜ê°€ ë¹„ì •ìƒ (bought_price={bought_price}) â†’ ê³„ì‚° ê±´ë„ˆëœ€")
            continue

        profit_pct = round(((current_price / bought_price) - 1) * 100, 2)

        # âœ… ë™ì  ì†ì ˆ ì„ê³„ì¹˜ ê³„ì‚°
        buy_count = count_buy_record(sym)
        mool_count = buy_count - 1
        adjusted_threshold = stop_loss_threshold + (mool_count * add_lose_pct)

        #--- # 1ï¸âƒ£ -5% ì´ìƒ ì†ì‹¤ ì‹œ ë¬´ì¡°ê±´ ì†ì ˆ
        #--- if profit_pct <= stop_abs_loss_threshold:
        #---     send_message(f"ğŸ˜­ [ì†ì ˆ]{info.get('ì¢…ëª©ëª…')}({sym}) ì†ì‹¤ {stop_abs_loss_threshold:.2f}% ì´ˆê³¼! ê°•ì œì†ì ˆ (ì†ì ˆë¥  {profit_pct:.2f}%)")
        #---     send_message_main(f"ğŸ˜­ [ì†ì ˆ]{info.get('ì¢…ëª©ëª…')}({sym}) ì†ì‹¤ {stop_abs_loss_threshold:.2f}% ì´ˆê³¼! ê°•ì œì†ì ˆ (ì†ì ˆë¥  {profit_pct:.2f}%)")
        #---     stopped.append(sym)
        #---     continue  # ë” ì´ìƒ ì²´í¬í•  í•„ìš” ì—†ìŒ
                                                             
        # 2ï¸âƒ£ íŠ¸ë ˆì¼ë§ ì†ì ˆ ì¡°ê±´ í™•ì¸
        if profit_pct < 0:
            # ìµœì € ì†ì‹¤ ê°±ì‹ 
            if sym not in trailing_losses or profit_pct > trailing_losses[sym]:
                trailing_losses[sym] = profit_pct

            # ì†ì‹¤ ë°˜ë“± í›„ ì¬í•˜ë½ ê°ì§€
            if trailing_losses[sym] - profit_pct >= trailing_rebound and profit_pct <= adjusted_threshold:

                # ë¬¼íƒ€ê¸° íšŸìˆ˜ ì œí•œ í™•ì¸
                if mool_count >= max_mooling:
                    if sym not in blocked_symbols:   # ğŸš« ì´ë¯¸ ë¡œê·¸ ì°ì€ ì¢…ëª©ì€ ìƒëµ
                        send_message(f"ğŸš« [ë¬¼íƒ€ê¸°ì¤‘ë‹¨]{info.get('ì¢…ëª©ëª…')}({sym}) "
                                     f"ë¬¼íƒ€ê¸° {max_mooling}íšŒ ë„ë‹¬ â†’ ì¶”ê°€ ë¬¼íƒ€ê¸° ë¶ˆê°€")
                        send_message_main(f"ğŸš« [ë¬¼íƒ€ê¸°ì¤‘ë‹¨]{info.get('ì¢…ëª©ëª…')}({sym}) "
                                          f"ë¬¼íƒ€ê¸° {max_mooling}íšŒ ë„ë‹¬ â†’ ì¶”ê°€ ë¬¼íƒ€ê¸° ë¶ˆê°€")
                        blocked_symbols.add(sym)  # âœ… ìƒíƒœ ê¸°ë¡
                else:
                    send_message(f"ğŸŸ¢ [ë¬¼íƒ€ê¸°ì‹ í˜¸ {mool_count+1}íšŒì°¨]{info.get('ì¢…ëª©ëª…')}({sym}) "
                                 f"ì†ì‹¤ë¥  {profit_pct:.2f}% (ì„ê³„ì¹˜ {adjusted_threshold:.2f}%) â†’ ë¬¼íƒ€ê¸° ëŒ€ìƒ")
                    send_message_main(f"ğŸŸ¢ [ë¬¼íƒ€ê¸°ì‹ í˜¸ {mool_count+1}íšŒì°¨]{info.get('ì¢…ëª©ëª…')}({sym}) "
                                      f"ì†ì‹¤ë¥  {profit_pct:.2f}% (ì„ê³„ì¹˜ {adjusted_threshold:.2f}%) â†’ ë¬¼íƒ€ê¸° ëŒ€ìƒ")
                    stopped.append(sym)
        else:
            # ì†ì‹¤ì´ ì•„ë‹Œ ê²½ìš° ê¸°ë¡ ì œê±°
            if sym in trailing_losses:
                trailing_losses.pop(sym, None)

    return stopped

# --- âœ¨ ìµì ˆ (Trailing Stop) ë¡œì§ í•¨ìˆ˜ + ë¶ˆíƒ€ê¸° âœ¨ ---
def check_profit_taking_with_trailing_stop(
    stock_dict,
    trailing_peak_prices,
    break_even_pct1,
    break_even_lose_pct1,
    break_even_pct2,
    break_even_lose_pct2,
    break_even_pct3,
    break_even_lose_pct3,
    take_profit_pct,
    take_profit_lose_pct
):
    """
    4ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ë¡œì§ + ë¶ˆíƒ€ê¸° ì‹ í˜¸ ìƒì„±
    """
    profited = []
    burn_in_list = []

    for sym, info in stock_dict.items():
        current_price = get_current_price(sym)
        if current_price is None:
            continue

        bought_price = info.get('ë§¤ìˆ˜ê°€')
        if bought_price is None or bought_price == 0:
            continue

        profit_pct = round(((current_price / bought_price) - 1) * 100, 2)
        sym_name = info.get('ì¢…ëª©ëª…', sym)

        # ì´ˆê¸° ìƒíƒœ ë“±ë¡
        if sym not in trailing_peak_prices:
            if profit_pct >= break_even_pct1:
                send_message(f"ğŸŸ¡ {sym_name}({sym}) {break_even_pct1}% ë„ë‹¬ â†’ 1ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ì‹œì‘")
                send_message_main(f"ğŸŸ¡ {sym_name}({sym}) {break_even_pct1}% ë„ë‹¬ â†’ 1ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ì‹œì‘")
                trailing_peak_prices[sym] = {'stage': 1, 'peak_price': current_price}
                burn_in_list.append(sym)  # 1ë‹¨ê³„ ë„ë‹¬ì‹œë§Œ ë¶ˆíƒ€ê¸° ìˆ˜í–‰
            continue

        # ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°
        stage = trailing_peak_prices[sym]['stage']
        peak_price = trailing_peak_prices[sym]['peak_price']

        # ìµœê³ ê°€ ê°±ì‹ 
        if current_price > peak_price:
            trailing_peak_prices[sym]['peak_price'] = current_price
            peak_price = current_price

        # --- 1ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ---
        if stage == 1:
            if profit_pct >= break_even_pct2:
                send_message(f"ğŸŸ¡ğŸŸ¡ {sym_name}({sym}) {break_even_pct2}% ë„ë‹¬ â†’ 2ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ì‹œì‘")
                send_message_main(f"ğŸŸ¡ğŸŸ¡ {sym_name}({sym}) {break_even_pct2}% ë„ë‹¬ â†’ 2ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ì‹œì‘")
                trailing_peak_prices[sym] = {'stage': 2, 'peak_price': current_price}
            elif current_price <= peak_price * (1 - abs(break_even_lose_pct1) / 100):
                send_message(f"ğŸ˜„ [ë‹¨ê³„1]{sym_name}({sym}) 1ë‹¨ê³„ ìµœê³ ê°€ ëŒ€ë¹„ {abs(break_even_lose_pct1)}% í•˜ë½! (ìµì ˆë¥  {profit_pct:.2f}%)")
                send_message_main(f"ğŸ˜„ [ë‹¨ê³„1]{sym_name}({sym}) 1ë‹¨ê³„ ìµœê³ ê°€ ëŒ€ë¹„ {abs(break_even_lose_pct1)}% í•˜ë½! (ìµì ˆë¥  {profit_pct:.2f}%)")
                profited.append(sym)

        # --- 2ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ---
        elif stage == 2:
            if profit_pct >= break_even_pct3:
                send_message(f"ğŸŸ¡ğŸŸ¡ğŸŸ¡ {sym_name}({sym}) {break_even_pct3}% ë„ë‹¬ â†’ 3ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ì‹œì‘")
                send_message_main(f"ğŸŸ¡ğŸŸ¡ğŸŸ¡ {sym_name}({sym}) {break_even_pct3}% ë„ë‹¬ â†’ 3ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ì‹œì‘")
                trailing_peak_prices[sym] = {'stage': 3, 'peak_price': current_price}
            elif current_price <= peak_price * (1 - abs(break_even_lose_pct2) / 100):
                send_message(f"ğŸ˜„ğŸ˜„ [ë‹¨ê³„2]{sym_name}({sym}) 2ë‹¨ê³„ ìµœê³ ê°€ ëŒ€ë¹„ {abs(break_even_lose_pct2)}% í•˜ë½! (ìµì ˆë¥  {profit_pct:.2f}%)")
                send_message_main(f"ğŸ˜„ğŸ˜„ [ë‹¨ê³„2]{sym_name}({sym}) 2ë‹¨ê³„ ìµœê³ ê°€ ëŒ€ë¹„ {abs(break_even_lose_pct2)}% í•˜ë½! (ìµì ˆë¥  {profit_pct:.2f}%)")
                profited.append(sym)

        # --- 3ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ---
        elif stage == 3:
            if profit_pct >= take_profit_pct:
                send_message(f"ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ {sym_name}({sym}) {take_profit_pct}% ë„ë‹¬ â†’ 4ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ì‹œì‘")
                send_message_main(f"ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ {sym_name}({sym}) {take_profit_pct}% ë„ë‹¬ â†’ 4ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ì‹œì‘")
                trailing_peak_prices[sym] = {'stage': 4, 'peak_price': current_price}
            elif current_price <= peak_price * (1 - abs(break_even_lose_pct3) / 100):
                send_message(f"ğŸ˜„ğŸ˜„ğŸ˜„ [ë‹¨ê³„3]{sym_name}({sym}) 3ë‹¨ê³„ ìµœê³ ê°€ ëŒ€ë¹„ {abs(break_even_lose_pct3)}% í•˜ë½! (ìµì ˆë¥  {profit_pct:.2f}%)")
                send_message_main(f"ğŸ˜„ğŸ˜„ğŸ˜„ [ë‹¨ê³„3]{sym_name}({sym}) 3ë‹¨ê³„ ìµœê³ ê°€ ëŒ€ë¹„ {abs(break_even_lose_pct3)}% í•˜ë½! (ìµì ˆë¥  {profit_pct:.2f}%)")
                profited.append(sym)

        # --- 4ë‹¨ê³„ íŠ¸ë ˆì¼ë§ ---
        elif stage == 4:
            if current_price <= peak_price * (1 - abs(take_profit_lose_pct) / 100):
                send_message(f"ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ [ë‹¨ê³„4]{sym_name}({sym}) 4ë‹¨ê³„ ìµœê³ ê°€ ëŒ€ë¹„ {abs(take_profit_lose_pct)}% í•˜ë½! (ìµì ˆë¥  {profit_pct:.2f}%)")
                send_message_main(f"ğŸ˜„ğŸ˜„ğŸ˜„ğŸ˜„ [ë‹¨ê³„4]{sym_name}({sym}) 4ë‹¨ê³„ ìµœê³ ê°€ ëŒ€ë¹„ {abs(take_profit_lose_pct)}% í•˜ë½! (ìµì ˆë¥  {profit_pct:.2f}%)")
                profited.append(sym)

    return profited, burn_in_list

def get_current_price(code="005930"):
    """
    í˜„ì¬ê°€ ì¡°íšŒ í•¨ìˆ˜ (ì¬ì‹œë„ í¬í•¨)
    - ìµœëŒ€ 3ë²ˆê¹Œì§€ ì¬ì‹œë„
    - ê° ì¬ì‹œë„ë§ˆë‹¤ ëŒ€ê¸°ì‹œê°„ ì¦ê°€ (1ì´ˆ â†’ 2ì´ˆ â†’ 3ì´ˆ)
    """
    PATH = "uapi/domestic-stock/v1/quotations/inquire-price"
    URL = f"{URL_BASE}/{PATH}"
    headers = {
        "Content-Type": "application/json",
        "authorization": f"Bearer {ACCESS_TOKEN}",
        "appKey": APP_KEY,
        "appSecret": APP_SECRET,
        "tr_id": "FHKST01010100"
    }
    params = {
        "fid_cond_mrkt_div_code": "J",
        "fid_input_iscd": code,
    }

    time.sleep(0.05)
    for i in range(3):  # ìµœëŒ€ 3íšŒ ì¬ì‹œë„
        try:
            res = requests.get(URL, headers=headers, params=params, timeout=5)

            if res.status_code == 200:
                result = res.json()
                price_str = result.get('output', {}).get('stck_prpr')

                if price_str is None:
                    send_message(f"[{code}] í˜„ì¬ê°€ ì‘ë‹µì— ê°€ê²© ì •ë³´ ì—†ìŒ")
                    return None

                current_price = int(price_str)
                return current_price
            else:
                send_message(f"[{code}] í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨ (HTTP {res.status_code}) - ì¬ì‹œë„ {i+1}/3")
                time.sleep(1 * (i + 1))  # 1ì´ˆ â†’ 2ì´ˆ â†’ 3ì´ˆ ëŒ€ê¸°

        except Exception as e:
            send_message(f"[{code}] í˜„ì¬ê°€ ì¡°íšŒ ì˜ˆì™¸ ë°œìƒ: {e} - ì¬ì‹œë„ {i+1}/3")
            time.sleep(1 * (i + 1))

    send_message(f"[{code}] âŒ í˜„ì¬ê°€ ì¡°íšŒ ìµœì¢… ì‹¤íŒ¨. í•´ë‹¹ ì¢…ëª©ì€ ê±´ë„ˆëœë‹ˆë‹¤.")
    return None

def get_price_info(code="005930", k_base=0.5, gap_threshold=0.03, p_stock_name="ì‚¼ì„±ì „ì"):
    """
    ë³€ë™ì„± ëŒíŒŒ ì „ëµ ëª©í‘œê°€ + ë‹¹ì¼ ì‹œê°€ë¥¼ í•¨ê»˜ ë°˜í™˜
    ì „ì¼ ì¢…ê°€ ëŒ€ë¹„ ì¼ì • % ì´ìƒ ê°­í•˜ë½ ì‹œ ë§¤ìˆ˜ ì œì™¸
    :param code: ì¢…ëª© ì½”ë“œ (6ìë¦¬ ë¬¸ìì—´)
    :param k_base: ë³€ë™ì„± ê³„ìˆ˜ (ê¸°ë³¸ê°’ 0.5)
    :param gap_threshold: ê°­ í•˜ë½ í—ˆìš© í•œë„ (ê¸°ë³¸ê°’ 3% -> 0.03)
    :return: (target_price, open_price) or (None, None)
    """
    PATH = "uapi/domestic-stock/v1/quotations/inquire-daily-price"
    URL = f"{URL_BASE}/{PATH}"
    headers = {
        "Content-Type":"application/json", 
        "authorization": f"Bearer {ACCESS_TOKEN}",
        "appKey":APP_KEY,
        "appSecret":APP_SECRET,
        "tr_id":"FHKST01010400"
    }
    params = {
        "fid_cond_mrkt_div_code":"J",
        "fid_input_iscd":code,
        "fid_org_adj_prc":"1",
        "fid_period_div_code":"D"
    }

    time.sleep(0.05)
    try:
        res = requests.get(URL, headers=headers, params=params)
        if res.status_code != 200:
            send_message(f"[{code}] ê°€ê²© ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨ (HTTP {res.status_code})")
            return None, None

        output = res.json().get("output")
        if not output or len(output) < 2:
            send_message(f"[{code}] ì¼ë´‰ ë°ì´í„° ë¶€ì¡± ë˜ëŠ” ì—†ìŒ.")
            return None, None

        # 1. í•„ìš”í•œ ê°€ê²©ë“¤ ì •ì˜
        # ì˜¤ëŠ˜ ì‹œê°€
        open_price = int(output[0]['stck_oprc'])
        #stock_name = output[0].get('hts_kor_isnm', '')  # ì¢…ëª©ëª… ì¶”ê°€
        stock_name = p_stock_name
        # ì „ì¼ ì‹œê°€/ì¢…ê°€/ê³ ê°€/ì €ê°€
        prev_open  = int(output[1]['stck_oprc'])
        prev_close = int(output[1]['stck_clpr'])
        prev_high  = int(output[1]['stck_hgpr'])
        prev_low   = int(output[1]['stck_lwpr'])

        # ë³€ë™ì„± ëŒíŒŒ ëª©í‘œê°€ ê³„ì‚°
        #total_range = prev_high - prev_low
        total_range = prev_high - prev_open
        #total_range = prev_close - prev_open
        kplusvalue = total_range * k_base
        target_price = int(open_price + kplusvalue)

        # -------------------------------
        # ğŸ“Œ ê°­ í•˜ë½/ê°­ ìƒìŠ¹ í•„í„° (ì „ì¼ ì¢…ê°€ ëŒ€ë¹„ % ê¸°ì¤€)
        # -------------------------------
        gap_rate = (open_price - prev_close) / prev_close

        # ê°­ í•˜ë½
        if gap_rate <= -gap_threshold:
            msg = f"[{code}]{stock_name} ê°­í•˜ë½ {gap_rate*100:.2f}% ë°œìƒ -> ë§¤ìˆ˜í’€ì—ì„œ ì œê±°"
            send_message(msg)
            send_message_main(msg)
            selected_symbols_map.pop(code, None)
            return None, None

        # ê°­ ìƒìŠ¹
        if gap_rate >= gap_threshold:
            msg = f"[{code}]{stock_name} ê°­ìƒìŠ¹ {gap_rate*100:.2f}% ë°œìƒ -> ë§¤ìˆ˜í’€ì—ì„œ ì œê±°"
            send_message(msg)
            send_message_main(msg)
            selected_symbols_map.pop(code, None)
            return None, None

        return target_price, open_price

    except (ConnectTimeout, ReadTimeout, Timeout, ConnectionError) as e:
        send_message(f"[{code}] ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì˜¤ë¥˜/íƒ€ì„ì•„ì›ƒ: {e}")
        return None, None
        
    except (KeyError, ValueError) as e:
        send_message(f"[{code}] ê°€ê²© ì •ë³´ íŒŒì‹± ì˜¤ë¥˜: {e}")
        return None, None
        
    except Exception as e:
        send_message(f"[{code}] ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {e}")
        return None, None

def format_krw(val):
    """ìˆ«ì(ë˜ëŠ” ìˆ«ì ë¬¸ìì—´)ë¥¼ ì²œ ë‹¨ìœ„ ì½¤ë§ˆë¡œ í¬ë§·í•˜ì—¬ ë¬¸ìì—´ ë°˜í™˜.
       ìˆ«ìê°€ ì•„ë‹ˆë©´ 'N/A' ë°˜í™˜ (ë‹¨ìœ„ì€ í•¨ìˆ˜ì—ì„œ ë¶™ì„)."""
    if val is None:
        return "N/A"
    # ë¬¸ìì—´ì´ë©´ ì‰¼í‘œ/ê³µë°± ì œê±° í›„ ìˆ«ì ë³€í™˜ ì‹œë„
    try:
        if isinstance(val, str):
            s = val.strip()
            if s == "":
                return "N/A"
            s = s.replace(",", "")         # "1,000" ê°™ì€ ê²½ìš° ì œê±°
            num = float(s)
        else:
            num = float(val)
    except Exception:
        return "N/A"

    # ì •ìˆ˜ì´ë©´ ì •ìˆ˜ í˜•íƒœë¡œ í¬ë§·, ì•„ë‹ˆë©´ ì†Œìˆ˜ 2ìë¦¬ë¡œ í¬ë§· (í•„ìš”í•˜ë©´ ì¡°ì •)
    if num.is_integer():
        return f"{int(num):,}ì›"
    else:
        return f"{num:,.2f}ì›"

def get_stock_balance():
    """ì£¼ì‹ ì”ê³ ì¡°íšŒ - ì—°ì† ì¡°íšŒ ì§€ì›"""
    PATH = "uapi/domestic-stock/v1/trading/inquire-balance"
    URL = f"{URL_BASE}/{PATH}"

    stock_dict = {}
    stock_info_list = []
    item_count = 0
    evaluation = []  # <- ì¶”ê°€

    # ì´ˆê¸° í—¤ë”/íŒŒë¼ë¯¸í„°
    headers = {
        "Content-Type": "application/json",
        "authorization": f"Bearer {ACCESS_TOKEN}",
        "appKey": APP_KEY,
        "appSecret": APP_SECRET,
        "tr_id": "TTTC8434R",
        "tr_cont": "",       # ì²« í˜¸ì¶œ ì‹œ ê³µë°±
        "custtype": "P",
    }

    params = {
        "CANO": CANO,
        "ACNT_PRDT_CD": ACNT_PRDT_CD,
        "AFHR_FLPR_YN": "N",
        "OFL_YN": "",
        "INQR_DVSN": "02",
        "UNPR_DVSN": "01",
        "FUND_STTL_ICLD_YN": "N",
        "FNCG_AMT_AUTO_RDPT_YN": "N",
        "PRCS_DVSN": "01",
        "CTX_AREA_FK100": "",  # ì²« í˜¸ì¶œ ì‹œ ê³µë°±
        "CTX_AREA_NK100": ""   # ì²« í˜¸ì¶œ ì‹œ ê³µë°±
    }

    page = 1
    max_pages = 100  # ë¬´í•œë£¨í”„ ë°©ì§€ìš©

    while True:
        #time.sleep(0.3)  # <-- API í˜¸ì¶œ ì œí•œ íšŒí”¼ìš© ë”œë ˆì´
        res = requests.get(URL, headers=headers, params=params)
        if res.status_code != 200:
            msg1 = res.json().get('msg1', '')
            if 'ì´ˆë‹¹ ê±°ë˜ê±´ìˆ˜' in msg1:
                send_message("[WARN] ì´ˆë‹¹ ê±°ë˜ê±´ìˆ˜ ì´ˆê³¼ â€” 1ì´ˆ ëŒ€ê¸° í›„ ì¬ì‹œë„")
                time.sleep(1)
                continue  # ì¬ì‹œë„
            else:
                send_message(f"[ERROR] ì£¼ì‹ ì”ê³  ì¡°íšŒ ì‹¤íŒ¨: {msg1}")
                sys.exit(1)  # â† í”„ë¡œê·¸ë¨ ê°•ì œ ì¢…ë£Œ, #return stock_dict  #break

        response_data = res.json()
        stock_list = response_data.get('output1', [])
        evaluation = response_data.get('output2', [])

        ctx_fk = response_data.get('ctx_area_fk100', '')
        ctx_nk = response_data.get('ctx_area_nk100', '')

        # ë°›ì€ ë°ì´í„° ì²˜ë¦¬
        for stock in stock_list:
            symbol = stock.get('pdno')
            hldg_qty = int(stock.get('hldg_qty', 0))
            buy_price = float(stock.get('pchs_avg_pric', 0))
            product_name = stock.get('prdt_name')
            if hldg_qty > 0:
                item_count += 1
                stock_dict[symbol] = {
                    'ì¢…ëª©ëª…': product_name,
                    'í˜„ì¬ìˆ˜ëŸ‰': hldg_qty,
                    'ë§¤ìˆ˜ê°€': buy_price
                }
                stock_info_list.append(f"{item_count:02d}.{product_name}({symbol})")

        # ë‹¤ìŒ í˜ì´ì§€ ì—¬ë¶€ í™•ì¸
        tr_cont = res.headers.get('tr_cont', '')
        if tr_cont in ['F', 'M'] and page < max_pages:
            headers['tr_cont'] = "N"   # ì—°ì† ì¡°íšŒìš©
            params['CTX_AREA_FK100'] = ctx_fk
            params['CTX_AREA_NK100'] = ctx_nk
            page += 1
        else:
            break  # ë§ˆì§€ë§‰ í˜ì´ì§€ ë˜ëŠ” ìµœëŒ€ í˜ì´ì§€ ë„ë‹¬

    # ê²°ê³¼ ë©”ì‹œì§€ ì¶œë ¥
    send_message(f"====ì£¼ì‹ ë³´ìœ ì”ê³ ====")
    if item_count > 0:
        send_message(f"ğŸ“‹ ì „ì²´ ë³´ìœ  ì£¼ì‹: {item_count}ê±´")
        send_message_main(f"ğŸ“‹ ì „ì²´ ë³´ìœ  ì£¼ì‹: {item_count}ê±´")
        # ì›í•˜ëŠ” ê²½ìš° ì¢…ëª© ë¦¬ìŠ¤íŠ¸ë„ ì¶œë ¥
        # send_message(f"{':'.join(stock_info_list)}")
    else:
        send_message("ğŸ“‹ í˜„ì¬ ë³´ìœ  ì£¼ì‹ì€ ì—†ìŠµë‹ˆë‹¤.")

    if evaluation:
        scts = evaluation[0].get('scts_evlu_amt')
        evlu = evaluation[0].get('evlu_pfls_smtl_amt')
        tot  = evaluation[0].get('tot_evlu_amt')
        send_message(f"ğŸ’° ì£¼ì‹ í‰ê°€ ê¸ˆì•¡: {format_krw(scts)}")
        send_message(f"ğŸ’° í‰ê°€ ì†ìµ í•©ê³„: {format_krw(evlu)}")
        send_message_main(f"ğŸ’° í‰ê°€ ì†ìµ í•©ê³„: {format_krw(evlu)}")
        send_message(f"ğŸ’° ì´ í‰ê°€ ê¸ˆì•¡: {format_krw(tot)}")
    else:
        send_message("í‰ê°€ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.")
    send_message("=================")

    return stock_dict

def get_balance(pdno="005930", ord_unpr="65500"):
    """ìµœëŒ€ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡ ì¡°íšŒ"""
    PATH = "uapi/domestic-stock/v1/trading/inquire-psbl-order"
    URL = f"{URL_BASE}/{PATH}"
    headers = {"Content-Type":"application/json", 
        "authorization":f"Bearer {ACCESS_TOKEN}",
        "appKey":APP_KEY,
        "appSecret":APP_SECRET,
        "tr_id":"TTTC8908R",
        "custtype":"P",
    }
    params = {
        "CANO": CANO,
        "ACNT_PRDT_CD": ACNT_PRDT_CD,
        "PDNO": pdno,
        "ORD_UNPR": str(ord_unpr),   # ì£¼ë¬¸ê°€ê²©
        "ORD_DVSN": "01",            # ì§€ì •ê°€
        "CMA_EVLU_AMT_ICLD_YN": "N",
        "OVRS_ICLD_YN": "N"
    }
    res = requests.get(URL, headers=headers, params=params)
    if res.status_code != 200:
        send_message(f"ìµœëŒ€ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡ ì¡°íšŒ ì‹¤íŒ¨(HTTP {res.status_code})")
        return 0
    
    j = res.json()
    output = j.get('output', {})
    
    # ìµœëŒ€ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡ í•„ë“œë“¤
    max_ord_psbl_amt = output.get('max_buy_amt')  # ìµœëŒ€ë§¤ìˆ˜ê°€ëŠ¥ê¸ˆì•¡
    if max_ord_psbl_amt is None:
        max_ord_psbl_amt = output.get('ord_psbl_amt')  # ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡
    
    if max_ord_psbl_amt is None:
        send_message("ìµœëŒ€ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡ ì‘ë‹µì— ê°’ ì—†ìŒ")
        return 0
    
    try:
        return int(max_ord_psbl_amt)
    except:
        return 0

def buy(code="005930", qty="1"):
    """ì£¼ì‹ ì‹œì¥ê°€ ë§¤ìˆ˜"""  
    PATH = "uapi/domestic-stock/v1/trading/order-cash"
    URL = f"{URL_BASE}/{PATH}"
    data = {
        "CANO": CANO,
        "ACNT_PRDT_CD": ACNT_PRDT_CD,
        "PDNO": code,
        "ORD_DVSN": "01",
        "ORD_QTY": str(int(qty)),
        "ORD_UNPR": "0",
    }
    headers = {"Content-Type":"application/json", 
        "authorization":f"Bearer {ACCESS_TOKEN}",
        "appKey":APP_KEY,
        "appSecret":APP_SECRET,
        "tr_id":"TTTC0802U",
        "custtype":"P",
        "hashkey" : hashkey(data)
    }
    
    time.sleep(0.05)
    res = requests.post(URL, headers=headers, data=json.dumps(data))
    if res.json()['rt_cd'] == '0':
        send_message(f"[ë§¤ìˆ˜ ì„±ê³µ]{str(res.json())}")
        return True
    else:
        send_message(f"[ë§¤ìˆ˜ ì‹¤íŒ¨]{str(res.json())}")
        return False

def safe_buy(sym, buy_amount, current_price, stock_name):
    """
    ì£¼ë¬¸ ê°€ëŠ¥ ê¸ˆì•¡ì„ í™•ì¸í•˜ê³  ì•ˆì „í•˜ê²Œ ë§¤ìˆ˜
    - ìµœì´ˆ ì£¼ë¬¸ì€ ë²„í¼ 0% (1.00) ì ìš©
    - ì‹¤íŒ¨í•  ë•Œë§ˆë‹¤ 3%ì”© ë” ë³´ìˆ˜ì ìœ¼ë¡œ ì¤„ì—¬ì„œ ì¬ì‹œë„ (ìµœëŒ€ 6íšŒ)
    """
    if current_price is None or current_price <= 0:
        send_message(f"âš ï¸ {sym} ë§¤ìˆ˜ ë¶ˆê°€: í˜„ì¬ê°€ ì˜¤ë¥˜ ({current_price}), ë§¤ìˆ˜í’€ì—ì„œ ì œê±°")
        selected_symbols_map.pop(sym, None)
        return False

    # ìµœì´ˆ ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡ ì¡°íšŒ
    #max_cash = get_balance(pdno=sym, ord_unpr=current_price)
    max_cash = buy_amount
    if max_cash <= 0:
        send_message(f"âš ï¸ {sym} ë§¤ìˆ˜ ë¶ˆê°€: ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡ì´ 0ì›ìœ¼ë¡œ ì¡°íšŒë¨, ë§¤ìˆ˜í’€ì—ì„œ ì œê±°")
        selected_symbols_map.pop(sym, None)
        return False

    attempts = 0
    base_ratio = 1.00  # ì²« ì‹œë„ëŠ” 100% ë²„í¼
    while attempts < 6:
        # ì‹œë„ íšŸìˆ˜ì— ë”°ë¼ ë²„í¼ë¥¼ ì ì  ëŠ˜ë ¤ê° (ì˜ˆ: 100% -> 97% â†’ 94% â†’ 91% ...)
        ratio = base_ratio - (attempts * 0.03)

        safe_cash = int(min(buy_amount, max_cash) * ratio)
        qty_to_buy = int(safe_cash // current_price)
        total_buy_amt = qty_to_buy * current_price

        if qty_to_buy <= 0:
            send_message(f"âš ï¸ {sym} ë§¤ìˆ˜ ë¶ˆê°€: (safe_cash {safe_cash}ì›, í˜„ì¬ê°€ {current_price}ì›), ë§¤ìˆ˜í’€ì—ì„œ ì œê±°")
            selected_symbols_map.pop(sym, None)
            return False

        send_message(f"ğŸŸ¢ {sym} ì£¼ë¬¸ì‹œë„({attempts+1}íšŒì°¨): ìˆ˜ëŸ‰={qty_to_buy}, ë‹¨ê°€={current_price}, ì´ì•¡={qty_to_buy*current_price:,}ì›, ì”ê³ ={buy_amount:,}ì›")
        ok = buy(sym, qty_to_buy)
        if ok:
            add_buy_record(sym, qty_to_buy, current_price, total_buy_amt, stock_name)
            return True

        # ì‹¤íŒ¨ â†’ ë‹¤ìŒ ë£¨í”„ì—ì„œ ë” ë³´ìˆ˜ì ìœ¼ë¡œ ì¤„ì—¬ì„œ ì¬ì‹œë„
        attempts += 1
        time.sleep(0.2)  # API í˜¸ì¶œ ê°„ê²© í™•ë³´

    send_message(f"âš ï¸ {sym} ë§¤ìˆ˜ ì‹¤íŒ¨(6íšŒ ì¬ì‹œë„ í›„). ë§¤ìˆ˜í’€ì—ì„œ ì œê±°")
    selected_symbols_map.pop(sym, None)
    return False

def sell(code="005930", qty="1", stock_dict_cache=None, div="ëª¨ë¦„"):
    """ì£¼ì‹ ì‹œì¥ê°€ ë§¤ë„ (ë§¤ë„ ì „ ë³´ìœ ì •ë³´ ìŠ¤ëƒ…ìƒ· â†’ ë§¤ë„ í›„ ê¸°ë¡)"""
    # âœ… 1) ë§¤ë„ ì§ì „ ìŠ¤ëƒ…ìƒ· í™•ë³´
    pos = get_position_snapshot(code, stock_dict_cache=stock_dict_cache)
    pre_buy_price = pos['ë§¤ìˆ˜ê°€']
    pre_stock_name = pos['ì¢…ëª©ëª…']

    PATH = "uapi/domestic-stock/v1/trading/order-cash"
    URL = f"{URL_BASE}/{PATH}"
    data = {
        "CANO": CANO,
        "ACNT_PRDT_CD": ACNT_PRDT_CD,
        "PDNO": code,
        "ORD_DVSN": "01",
        "ORD_QTY": qty,
        "ORD_UNPR": "0",
    }
    headers = {"Content-Type":"application/json", 
        "authorization":f"Bearer {ACCESS_TOKEN}",
        "appKey":APP_KEY,
        "appSecret":APP_SECRET,
        "tr_id":"TTTC0801U",
        "custtype":"P",
        "hashkey" : hashkey(data)
    }

    time.sleep(0.05)
    res = requests.post(URL, headers=headers, data=json.dumps(data))
    if res.json().get('rt_cd') == '0':
        send_message(f"[ë§¤ë„ ì„±ê³µ]{str(res.json())}")

        # âœ… 2) ì²´ê²°ë‹¨ê°€ëŠ” ì£¼ë¬¸ì‘ë‹µì— ì •í™•íˆ ì—†ìœ¼ë‹ˆ, ê¸°ì¡´ëŒ€ë¡œ í˜„ì¬ê°€ë¡œ ê¸°ë¡ (ì›í•˜ë©´ ì²´ê²°ì¡°íšŒ APIë¡œ ëŒ€ì²´ ê°€ëŠ¥)
        sell_price = get_current_price(code) or 0

        # âœ… 3) ë§¤ë„ ì´ë ¥ ê¸°ë¡ (ìŠ¤ëƒ…ìƒ· ì‚¬ìš©)
        write_sell_history(
            code=code,
            qty=qty,
            sell_price=sell_price,
            buy_price=pre_buy_price,
            stock_name=pre_stock_name,
            div=div
        )

        # âœ… 4) BuyDate.ini ì—ì„œ ì œê±°
        remove_sell_record(code)
        return True
    else:
        send_message(f"[ë§¤ë„ ì‹¤íŒ¨]{str(res.json())}")
        return False

def load_settings():
    """Setting.ini íŒŒì¼ì—ì„œ ì„¤ì •ì„ ì½ì–´ì˜µë‹ˆë‹¤."""
    config = configparser.ConfigParser()
    config_path = 'C:\\StockPy_dp\\Setting.ini'

    try:
        config.read(config_path, encoding='utf-8')
        send_message(f"âœ… ì„¤ì • íŒŒì¼ '{config_path}'ì„(ë¥¼) ì„±ê³µì ìœ¼ë¡œ ì½ì—ˆìŠµë‹ˆë‹¤.")
    except Exception as e:
        send_message(f"âŒ ì„¤ì • íŒŒì¼ '{config_path}' ì½ê¸° ì‹¤íŒ¨: {e}")
        send_message("ê¸°ë³¸ ì„¤ì •ê°’ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.")
        return {
            'ACCOUNT_AMT': 7000000,
            'EXCLUDE_LIST': [],
            'TARGET_BUY_COUNT': 25,
            'T_9_TIME': {'hour': 9, 'minute': 0, 'second': 15},
            'T_START_TIME': {'hour': 9, 'minute': 3, 'second': 0},
            'T_SELL_TIME': {'hour': 14, 'minute': 3, 'second': 0},
            'T_EXIT_TIME': {'hour': 14, 'minute': 8, 'second': 0},
            'AMOUNT_TO_BUY': 350000,
            'STOP_ADD_LOSE_PCT': -5.0,
            'MAX_MOOLING': 5,
            'SLIPPAGE_LIMIT': 1.015,
            'STOP_LOSE_PCT': -3.0,
            'STOP_TRAILING_REBOUND': 1.0,
            'STOP_ABS_LOSE_PCT': -5.0,
            'BREAK_EVEN_PCT1' : 3.0,
            'BREAK_EVEN_LOSE_PCT1' : 2.0,
            'BURN_IN_RATIO' : 0.5,
            'BREAK_EVEN_PCT2' : 5.0,
            'BREAK_EVEN_LOSE_PCT2' : 2.0,
            'BREAK_EVEN_PCT3' : 7.0,
            'BREAK_EVEN_LOSE_PCT3' : 2.0,
            'TAKE_PROFIT_PCT': 9.0,
            'TAKE_PROFIT_LOSE_PCT': 2.0,
            'AMOUNT_LIMIT1_TIME': {'hour': 13, 'minute': 0, 'second': 0},
            'AMOUNT_LIMIT1': 0.7,
            'AMOUNT_LIMIT2_TIME': {'hour': 13, 'minute': 30, 'second': 0},
            'AMOUNT_LIMIT2': 0.5,
            'TARGET_K1': 0.7,
            'TARGET_K2_TIME': {'hour': 13, 'minute': 0, 'second': 0},
            'TARGET_K2': 0.5,
            'TARGET_K3_TIME': {'hour': 13, 'minute': 30, 'second': 0},
            'TARGET_K3': 0.3,
            'TOTAL_LOSE_EXIT_PCT' : -2.2,
            'POOL_COUNT' : 15
        }

    settings = {}
    try:
        settings['ACCOUNT_AMT'] = config.getint('General', 'ACCOUNT_AMT')
        exclude_list_str = config.get('General', 'EXCLUDE_LIST', fallback='')
        settings['EXCLUDE_LIST'] = [item.strip() for item in exclude_list_str.split(',') if item.strip()] if exclude_list_str else []
        settings['TARGET_BUY_COUNT'] = config.getint('General', 'TARGET_BUY_COUNT')

        def parse_time_setting(config_obj, prefix):
            hour = config_obj.getint('TimeSettings', f'{prefix}_HOUR')
            minute = config_obj.getint('TimeSettings', f'{prefix}_MINUTE')
            second = config_obj.getint('TimeSettings', f'{prefix}_SECOND')
            return {'hour': hour, 'minute': minute, 'second': second}

        settings['T_9_TIME'] = parse_time_setting(config, 'T_9')
        settings['T_START_TIME'] = parse_time_setting(config, 'T_START')
        settings['T_SELL_TIME'] = parse_time_setting(config, 'T_SELL')
        settings['T_EXIT_TIME'] = parse_time_setting(config, 'T_EXIT')
        settings['AMOUNT_LIMIT1_TIME'] = parse_time_setting(config, 'AMOUNT_LIMIT1')
        settings['AMOUNT_LIMIT2_TIME'] = parse_time_setting(config, 'AMOUNT_LIMIT2')
        settings['TARGET_K2_TIME'] = parse_time_setting(config, 'TARGET_K2')
        settings['TARGET_K3_TIME'] = parse_time_setting(config, 'TARGET_K3')

        settings['AMOUNT_TO_BUY'] = config.getfloat('StrategyParameters', 'AMOUNT_TO_BUY')
        settings['STOP_ADD_LOSE_PCT'] = config.getfloat('StrategyParameters', 'STOP_ADD_LOSE_PCT')
        settings['MAX_MOOLING'] = config.getint('StrategyParameters', 'MAX_MOOLING')
        settings['SLIPPAGE_LIMIT'] = config.getfloat('StrategyParameters', 'SLIPPAGE_LIMIT')
        settings['STOP_LOSE_PCT'] = config.getfloat('StrategyParameters', 'STOP_LOSE_PCT')
        settings['STOP_TRAILING_REBOUND'] = config.getfloat('StrategyParameters', 'STOP_TRAILING_REBOUND')
        settings['STOP_ABS_LOSE_PCT'] = config.getfloat('StrategyParameters', 'STOP_ABS_LOSE_PCT')
        settings['BREAK_EVEN_PCT1'] = config.getfloat('StrategyParameters', 'BREAK_EVEN_PCT1')
        settings['BREAK_EVEN_LOSE_PCT1'] = config.getfloat('StrategyParameters', 'BREAK_EVEN_LOSE_PCT1')
        settings['BURN_IN_RATIO'] = config.getfloat('StrategyParameters', 'BURN_IN_RATIO')
        settings['BREAK_EVEN_PCT2'] = config.getfloat('StrategyParameters', 'BREAK_EVEN_PCT2')
        settings['BREAK_EVEN_LOSE_PCT2'] = config.getfloat('StrategyParameters', 'BREAK_EVEN_LOSE_PCT2')
        settings['BREAK_EVEN_PCT3'] = config.getfloat('StrategyParameters', 'BREAK_EVEN_PCT3')
        settings['BREAK_EVEN_LOSE_PCT3'] = config.getfloat('StrategyParameters', 'BREAK_EVEN_LOSE_PCT3')
        settings['TAKE_PROFIT_PCT'] = config.getfloat('StrategyParameters', 'TAKE_PROFIT_PCT')
        settings['TAKE_PROFIT_LOSE_PCT'] = config.getfloat('StrategyParameters', 'TAKE_PROFIT_LOSE_PCT')
        settings['AMOUNT_LIMIT1'] = config.getfloat('StrategyParameters', 'AMOUNT_LIMIT1')
        settings['AMOUNT_LIMIT2'] = config.getfloat('StrategyParameters', 'AMOUNT_LIMIT2')
        settings['TARGET_K1'] = config.getfloat('StrategyParameters', 'TARGET_K1')
        settings['TARGET_K2'] = config.getfloat('StrategyParameters', 'TARGET_K2')
        settings['TARGET_K3'] = config.getfloat('StrategyParameters', 'TARGET_K3')
        settings['TOTAL_LOSE_EXIT_PCT'] = config.getfloat('StrategyParameters', 'TOTAL_LOSE_EXIT_PCT')
        settings['POOL_COUNT'] = config.getint('StrategyParameters', 'POOL_COUNT')

    except (configparser.NoSectionError, configparser.NoOptionError, ValueError) as e:
        send_message(f"âŒ ì„¤ì • íŒŒì¼ íŒŒì‹± ì˜¤ë¥˜: {e}. ì„¤ì • ê°’ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.")
        return {
            'ACCOUNT_AMT': 7000000,
            'EXCLUDE_LIST': [],
            'TARGET_BUY_COUNT': 25,
            'T_9_TIME': {'hour': 9, 'minute': 0, 'second': 15},
            'T_START_TIME': {'hour': 9, 'minute': 3, 'second': 0},
            'T_SELL_TIME': {'hour': 14, 'minute': 3, 'second': 0},
            'T_EXIT_TIME': {'hour': 14, 'minute': 8, 'second': 0},
            'AMOUNT_TO_BUY': 350000,
            'STOP_ADD_LOSE_PCT': -5.0,
            'MAX_MOOLING': 5,
            'SLIPPAGE_LIMIT': 1.015,
            'STOP_LOSE_PCT': -3.0,
            'STOP_TRAILING_REBOUND': 1.0,
            'STOP_ABS_LOSE_PCT': -5.0,
            'BREAK_EVEN_PCT1' : 3.0,
            'BREAK_EVEN_LOSE_PCT1' : 2.0,
            'BURN_IN_RATIO' : 0.5,
            'BREAK_EVEN_PCT2' : 5.0,
            'BREAK_EVEN_LOSE_PCT2' : 2.0,
            'BREAK_EVEN_PCT3' : 7.0,
            'BREAK_EVEN_LOSE_PCT3' : 2.0,
            'TAKE_PROFIT_PCT': 9.0,
            'TAKE_PROFIT_LOSE_PCT': 2.0,
            'AMOUNT_LIMIT1_TIME': {'hour': 12, 'minute': 0, 'second': 0},
            'AMOUNT_LIMIT1': 0.7,
            'AMOUNT_LIMIT2_TIME': {'hour': 13, 'minute': 0, 'second': 0},
            'AMOUNT_LIMIT2': 0.5,
            'TARGET_K1': 0.7,
            'TARGET_K2_TIME': {'hour': 12, 'minute': 0, 'second': 0},
            'TARGET_K2': 0.5,
            'TARGET_K3_TIME': {'hour': 13, 'minute': 0, 'second': 0},
            'TARGET_K3': 0.3,
            'TOTAL_LOSE_EXIT_PCT' : -2.2,
            'POOL_COUNT' : 15
        }

    return settings

def load_reload_setting():
    """SettingReload.ini íŒŒì¼ì—ì„œ RELOAD ê°’ì„ ì½ì–´ì˜µë‹ˆë‹¤."""
    RELOAD_CONFIG.read(RELOAD_CONFIG_PATH, encoding='utf-8')
    try:
        return RELOAD_CONFIG.getboolean('General', 'RELOAD', fallback=False)
    except (configparser.NoSectionError, configparser.NoOptionError, ValueError) as e:
        send_message(f"âŒ SettingReload.ini ì½ê¸° ì˜¤ë¥˜: {e}. ê¸°ë³¸ê°’ FALSEë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.")
        return False

def write_reload_setting(value):
    """SettingReload.ini íŒŒì¼ì˜ RELOAD ê°’ì„ ì”ë‹ˆë‹¤."""
    if not RELOAD_CONFIG.has_section('General'):
        RELOAD_CONFIG.add_section('General')
    RELOAD_CONFIG.set('General', 'RELOAD', str(value).upper()) # TRUE/FALSEë¡œ ì €ì¥
    try:
        with open(RELOAD_CONFIG_PATH, 'w', encoding='utf-8') as f:
            RELOAD_CONFIG.write(f)
        send_message(f"âœ… SettingReload.ini RELOAD ê°’ì„ {value}ë¡œ ì—…ë°ì´íŠ¸í–ˆìŠµë‹ˆë‹¤.")
    except Exception as e:
        send_message(f"âŒ SettingReload.ini ì“°ê¸° ì˜¤ë¥˜: {e}")



BUYDATE_FILE = "C:\\StockPy_dp\\BuyDate.ini"
BUYDATE_HISTORY_FILE = "C:\\StockPy_dp\\BuyDate_History.ini"
SELLHISTORY_FILE = "C:\\StockPy_dp\\SellHistory.ini"

def count_buy_record(sym):
    """BUYDATE_FILEì—ì„œ íŠ¹ì • symbolì´ ëª‡ ê°œ ìˆëŠ”ì§€ count"""
    if not os.path.exists(BUYDATE_FILE):
        return 1

    count = 0
    with open(BUYDATE_FILE, "r", encoding="utf-8") as f:
        for line in f:
            if not line.strip():
                continue
            parts = line.strip().split(maxsplit=2)  # ë‚ ì§œ / ì‹¬ë³¼ / ì¢…ëª©ëª…
            if len(parts) >= 2 and parts[1] == sym:
                count += 1
    # countê°€ 0ì´ë©´ 1ì„ return
    return count if count > 0 else 1

def get_position_snapshot(code, stock_dict_cache=None):
    """
    ë§¤ë„ ì „ì— ë³´ìœ ì •ë³´ ìŠ¤ëƒ…ìƒ·ì„ í™•ë³´.
    - stock_dict_cache ê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ìš°ì„  ì‚¬ìš©(ë£¨í”„ì—ì„œ ì´ë¯¸ ì¡°íšŒí•œ ìµœì‹  ë³´ìœ ëª©ë¡ ì „ë‹¬)
    - ì—†ìœ¼ë©´ get_stock_balance()ë¡œ ì¡°íšŒ
    """
    stock_dict = stock_dict_cache if stock_dict_cache is not None else get_stock_balance()
    info = stock_dict.get(code, {}) if isinstance(stock_dict, dict) else {}

    # í‚¤ ëª… ë³´í˜¸ì ìœ¼ë¡œ ì²˜ë¦¬ (í™˜ê²½ ë”°ë¼ 'í‰ê· ë‹¨ê°€' ë“±ì¼ ìˆ˜ ìˆì–´ ë°±ì—… í‚¤ë„ í™•ì¸)
    buy_price = (
        info.get('ë§¤ìˆ˜ê°€')
        or info.get('í‰ê· ë‹¨ê°€')
        or info.get('ë§¤ì…ë‹¨ê°€')
        or 0
    )
    stock_name = (
        info.get('ì¢…ëª©ëª…')
        or (selected_symbols_map.get(code) if 'selected_symbols_map' in globals() else None)
        or "Unknown"
    )
    hold_qty = info.get('í˜„ì¬ìˆ˜ëŸ‰') or info.get('ë³´ìœ ìˆ˜ëŸ‰') or 0

    # ì •ìˆ˜/ë¬¸ì í˜¼í•© ì•ˆì „ ì²˜ë¦¬
    try:
        buy_price = int(buy_price)
    except Exception:
        buy_price = 0
    try:
        hold_qty = int(hold_qty)
    except Exception:
        hold_qty = 0

    return {
        'ì¢…ëª©ëª…': stock_name,
        'ë§¤ìˆ˜ê°€': buy_price,
        'í˜„ì¬ìˆ˜ëŸ‰': hold_qty,
    }

def write_sell_history(code, qty, sell_price, buy_price, stock_name, div):
    """
    ë§¤ë„ ì´ë ¥ ê¸°ë¡ (ì‚¬ì „ì— ìº¡ì²˜í•œ ë³´ìœ ì •ë³´ë¥¼ ì¸ìë¡œ ë°›ìŒ)
    ë§¤ìˆ˜ì¼/ë§¤ë„ì¼/ë³´ìœ ì¼ + ê¸°ì¡´ í•­ëª© ê¸°ë¡
    """
    today_str = datetime.now().strftime("%Y%m%d")  # ë§¤ë„ì¼
    
    # âœ… BuyDate.ini ì—ì„œ ë§¤ìˆ˜ì¼ ì°¾ê¸°
    buy_date_str = None
    if os.path.exists(BUYDATE_FILE):
        with open(BUYDATE_FILE, "r", encoding="utf-8") as f:
            for line in f:
                parts = line.strip().split(maxsplit=2)
                if len(parts) >= 2 and parts[1] == code:
                    buy_date_str = parts[0]  # ì²« ë²ˆì§¸ ì»¬ëŸ¼ì´ ë§¤ìˆ˜ì¼
                    break

    # ë§¤ìˆ˜ì¼ì´ ì—†ìœ¼ë©´ ì˜¤ëŠ˜ë¡œ ì²˜ë¦¬
    if not buy_date_str:
        buy_date_str = "20200101"

    # âœ… ë³´ìœ ì¼ ê³„ì‚° (ë§¤ë„ì¼ - ë§¤ìˆ˜ì¼)
    try:
        d_buy = datetime.strptime(buy_date_str, "%Y%m%d")
        d_sell = datetime.strptime(today_str, "%Y%m%d")
        hold_days = (d_sell - d_buy).days
    except Exception:
        hold_days = 0

    try:
        qty = int(qty)
    except Exception:
        qty = 0
    try:
        sell_price = int(sell_price) if sell_price is not None else 0
    except Exception:
        sell_price = 0
    try:
        buy_price = int(buy_price) if buy_price is not None else 0
    except Exception:
        buy_price = 0

    buy_total = buy_price * qty
    sell_total = sell_price * qty
    profit_rate = ( (sell_price / buy_price - 1) * 100 ) if buy_price > 0 else 0.0
    profit_amt = sell_total - buy_total

    # âœ… ë§¤ë„ ë¡œê·¸ ê¸°ë¡: [ë§¤ìˆ˜ì¼ ë§¤ë„ì¼ ë³´ìœ ì¼ ... ê¸°ì¡´ í•­ëª©]
    with open(SELLHISTORY_FILE, "a", encoding="utf-8") as f:
        f.write(
            f"{buy_date_str} {today_str} {hold_days} {code} {qty:,} {buy_price:,} {buy_total:,} "
            f"{sell_price:,} {sell_total:,} {profit_amt:,} {profit_rate:.2f}% {div} {stock_name}\n"
        )

def add_buy_record(sym, qty_to_buy, current_price, total_buy_amt, stock_name):
    """ë§¤ìˆ˜ ê¸°ë¡ ì¶”ê°€ (ë¬´ì¡°ê±´ ë§ˆì§€ë§‰ì— ì¶”ê°€)"""
    today_str = datetime.now().strftime("%Y%m%d")
    
    # íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ ë¬´ì¡°ê±´ ë§ˆì§€ë§‰ì— ê¸°ë¡
    with open(BUYDATE_FILE, "a", encoding="utf-8") as f:
        f.write(f"{today_str} {sym} {qty_to_buy:,} {current_price:,} {total_buy_amt:,} {stock_name}\n")

# --- â˜…â˜…â˜… ìš”ì²­ì‚¬í•­ì´ ë°˜ì˜ëœ ìˆ˜ì •ëœ í•¨ìˆ˜ â˜…â˜…â˜… ---
def remove_sell_record(sym):
    """ë§¤ë„ ì‹œ BuyDate.iniì—ì„œ í•´ë‹¹ ì¢…ëª©ì„ ì‚­ì œí•˜ê³ , ì‚­ì œëœ ë‚´ì—­ì€ BuyDate_History.iniì— ê¸°ë¡í•©ë‹ˆë‹¤."""
    if not os.path.exists(BUYDATE_FILE):
        print(f"ê²½ê³ : ì›ë³¸ íŒŒì¼({BUYDATE_FILE})ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        return

    try:
        # 1. ì›ë³¸ íŒŒì¼(BuyDate.ini)ì˜ ëª¨ë“  ë‚´ìš©ì„ ì½ì–´ì˜µë‹ˆë‹¤.
        with open(BUYDATE_FILE, "r", encoding="utf-8") as f:
            lines = f.readlines()
        
        # 2. ì›ë³¸ íŒŒì¼ì€ 'ë®ì–´ì“°ê¸°(w)' ëª¨ë“œë¡œ, ë°±ì—… íŒŒì¼ì€ 'ì¶”ê°€(a)' ëª¨ë“œë¡œ ì—½ë‹ˆë‹¤.
        #    ì´ë ‡ê²Œ í•˜ë©´ íŒŒì¼ì„ í•œ ë²ˆë§Œ ìˆœíšŒí•˜ë©´ì„œ ë‘ ê°€ì§€ ì‘ì—…ì„ ë™ì‹œì— ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        with open(BUYDATE_FILE, "w", encoding="utf-8") as f_buy_new, \
             open(BUYDATE_HISTORY_FILE, "a", encoding="utf-8") as f_history:
            
            # 3. ì½ì–´ì˜¨ ëª¨ë“  ë¼ì¸ì„ í•˜ë‚˜ì”© í™•ì¸í•©ë‹ˆë‹¤.
            for line in lines:
                if not line.strip():  # ë¹ˆ ì¤„ì€ ê±´ë„ˆëœë‹ˆë‹¤.
                    continue
                
                parts = line.strip().split(maxsplit=2)
                
                # 4. ë¼ì¸ì—ì„œ ë¶„ë¦¬í•œ ë‘ ë²ˆì§¸ ìš”ì†Œ(ì¢…ëª© ì½”ë“œ)ê°€ ë§¤ë„í•œ ì¢…ëª©(sym)ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
                if len(parts) >= 2 and parts[1] == sym:
                    # 5. ì¼ì¹˜í•˜ë©´, í•´ë‹¹ ë¼ì¸ì„ BuyDate_History.iniì— ì”ë‹ˆë‹¤. (ë°±ì—…)
                    f_history.write(line)
                    # continueë¥¼ í†µí•´ ì•„ë˜ f_buy_new.write(line)ê°€ ì‹¤í–‰ë˜ì§€ ì•Šë„ë¡ í•˜ì—¬
                    # BuyDate.iniì—ì„œëŠ” í•´ë‹¹ ë¼ì¸ì´ ì‚­ì œë˜ëŠ” íš¨ê³¼ë¥¼ ì¤ë‹ˆë‹¤.
                    continue
                
                # 6. ë§¤ë„í•œ ì¢…ëª©ì´ ì•„ë‹ˆë©´, í•´ë‹¹ ë¼ì¸ì„ BuyDate.iniì— ë‹¤ì‹œ ì”ë‹ˆë‹¤. (ìœ ì§€)
                f_buy_new.write(line)

        #print(f"'{sym}' ì¢…ëª©ì„ {BUYDATE_FILE}ì—ì„œ ì‚­ì œí•˜ê³  {BUYDATE_HISTORY_FILE}ì— ë°±ì—…í–ˆìŠµë‹ˆë‹¤.")

    except IOError as e:
        print(f"íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")

def get_old_symbols(days=5):
    """
    BUYDATE_FILEì—ì„œ daysì¼ ì´ìƒ ë³´ìœ í•œ ì¢…ëª© ì¡°íšŒ
    """
    old_symbols = []
    six_days_ago = (datetime.now() - timedelta(days=days)).strftime("%Y%m%d")

    if not os.path.exists(BUYDATE_FILE):
        return old_symbols

    with open(BUYDATE_FILE, "r", encoding="utf-8") as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) < 3:
                continue
            buy_date = parts[0]
            symbol = parts[1]
            stock_name = " ".join(parts[2:])  # ë„ì–´ì“°ê¸° ìˆëŠ” ì¢…ëª©ëª… í•©ì¹˜ê¸°
            if buy_date <= six_days_ago:
                old_symbols.append((symbol, stock_name))

    return old_symbols

def can_additional_buy():
    """ê³„ì¢Œ ì”ê³  í™•ì¸ í›„ ì¶”ê°€ë§¤ìˆ˜ ê°€ëŠ¥ ì—¬ë¶€ ë°˜í™˜"""
    balance = get_balance()
    if balance is None:
        return False
    return balance >= AMOUNT_TO_BUY

def print_today_sell_history():
    """SellHistory.ini ì—ì„œ ë§¤ë„ì¼ì´ ì˜¤ëŠ˜ì¸ ë‚´ì—­ê³¼ ì´ ìˆ˜ìµê¸ˆ ì¶œë ¥"""
    today_str = datetime.now().strftime("%Y%m%d")
    if not os.path.exists(SELLHISTORY_FILE):
        send_message("ğŸ“‚ SellHistory.ini íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        return

    total_cnt = 0
    total_profit = 0
    found = False
    with open(SELLHISTORY_FILE, "r", encoding="utf-8") as f:
        for line in f:
            if not line.strip():
                continue
            parts = line.strip().split(maxsplit=12)  # ì¢…ëª©ëª… í¬í•¨
            if len(parts) < 11:
                continue
            sell_date = parts[1]  # ë‘ ë²ˆì§¸ ì»¬ëŸ¼ì´ ë§¤ë„ì¼
            if sell_date == today_str:
                send_message("ğŸ“‘ ì˜¤ëŠ˜ ë§¤ë„ ë‚´ì—­: " + line.strip())
                try:
                    profit_amt = int(parts[9].replace(",", ""))  # 10ë²ˆì§¸ ì»¬ëŸ¼ (ìˆ˜ìµê¸ˆ)
                    total_cnt += 1
                    total_profit += profit_amt
                except Exception:
                    pass
                found = True

    if found:
        send_message(f"ğŸ“Š ì˜¤ëŠ˜ ì´ ìˆ˜ìµê¸ˆ: {total_cnt:,}ê±´ {total_profit:,}ì›")
        send_message("=================")
        send_message_main(f"ğŸ“Š ì˜¤ëŠ˜ ì´ ìˆ˜ìµê¸ˆ: {total_cnt:,}ê±´ {total_profit:,}ì›")
    else:
        send_message("ğŸ“‘ ì˜¤ëŠ˜ ë§¤ë„ ë‚´ì—­ ì—†ìŒ")
        send_message("=================")
        send_message_main("ğŸ“‘ ì˜¤ëŠ˜ ë§¤ë„ ë‚´ì—­ ì—†ìŒ")

def print_month_sell_history():
    """SellHistory.ini ì—ì„œ ì´ë²ˆë‹¬ ë§¤ë„ ë‚´ì—­ê³¼ ì´ ìˆ˜ìµê¸ˆ ì¶œë ¥"""
    today_str = datetime.now().strftime("%Y%m%d")
    this_month = today_str[:6]  # YYYYMM í˜•ì‹
    if not os.path.exists(SELLHISTORY_FILE):
        send_message("ğŸ“‚ SellHistory.ini íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        return

    total_cnt = 0
    total_profit = 0
    found = False
    with open(SELLHISTORY_FILE, "r", encoding="utf-8") as f:
        for line in f:
            if not line.strip():
                continue
            parts = line.strip().split(maxsplit=12)  # ì¢…ëª©ëª… í¬í•¨
            if len(parts) < 11:
                continue
            sell_date = parts[1]  # ë‘ ë²ˆì§¸ ì»¬ëŸ¼ì´ ë§¤ë„ì¼
            if sell_date.startswith(this_month):
                try:
                    profit_amt = int(parts[9].replace(",", ""))  # 10ë²ˆì§¸ ì»¬ëŸ¼ (ìˆ˜ìµê¸ˆ)
                    total_cnt += 1
                    total_profit += profit_amt
                except Exception:
                    pass
                found = True

    if found:
        send_message(f"ğŸ“Š {this_month}ì›” ì´ ìˆ˜ìµê¸ˆ: {total_cnt:,}ê±´ {total_profit:,}ì›")
        send_message("=================")
        send_message_main(f"ğŸ“Š {this_month}ì›” ì´ ìˆ˜ìµê¸ˆ: {total_cnt:,}ê±´ {total_profit:,}ì›")
    else:
        send_message(f"ğŸ“‘ {this_month}ì›” ë§¤ë„ ë‚´ì—­ ì—†ìŒ")
        send_message("=================")
        send_message_main(f"ğŸ“‘ {this_month}ì›” ë§¤ë„ ë‚´ì—­ ì—†ìŒ")

def print_year_sell_history():
    """SellHistory.ini ì—ì„œ ì˜¬í•´ ë§¤ë„ ë‚´ì—­ê³¼ ì´ ìˆ˜ìµê¸ˆ ì¶œë ¥"""
    today_str = datetime.now().strftime("%Y%m%d")
    this_year = today_str[:4]  # YYYY í˜•ì‹
    if not os.path.exists(SELLHISTORY_FILE):
        send_message("ğŸ“‚ SellHistory.ini íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        return

    total_cnt = 0
    total_profit = 0
    found = False
    with open(SELLHISTORY_FILE, "r", encoding="utf-8") as f:
        for line in f:
            if not line.strip():
                continue
            parts = line.strip().split(maxsplit=12)  # ì¢…ëª©ëª… í¬í•¨
            if len(parts) < 11:
                continue
            sell_date = parts[1]  # ë‘ ë²ˆì§¸ ì»¬ëŸ¼ì´ ë§¤ë„ì¼
            if sell_date.startswith(this_year):
                try:
                    profit_amt = int(parts[9].replace(",", ""))  # 10ë²ˆì§¸ ì»¬ëŸ¼ (ìˆ˜ìµê¸ˆ)
                    total_cnt += 1
                    total_profit += profit_amt
                except Exception:
                    pass
                found = True

    if found:
        send_message(f"ğŸ“Š {this_year}ë…„ ì´ ìˆ˜ìµê¸ˆ: {total_cnt:,}ê±´ {total_profit:,}ì›")
        send_message("=================")
        send_message_main(f"ğŸ“Š {this_year}ë…„ ì´ ìˆ˜ìµê¸ˆ: {total_cnt:,}ê±´ {total_profit:,}ì›")
    else:
        send_message(f"ğŸ“‘ {this_year}ë…„ ë§¤ë„ ë‚´ì—­ ì—†ìŒ")
        send_message("=================")
        send_message_main(f"ğŸ“‘ {this_year}ë…„ ë§¤ë„ ë‚´ì—­ ì—†ìŒ")
#***********************************************************************************************************
# ìë™ë§¤ë§¤ ì‹œì‘
try:
    msg = f"ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ StockPy_dp ìë™ë§¤ë§¤ ì‹œì‘"
    send_message(msg)
    send_message_main(msg)

    ACCESS_TOKEN = get_access_token()

    # --- âœ¨ ë©”ì¸ ìë™ë§¤ë§¤ ë£¨í”„ ì‹œì‘ âœ¨ ---
    # ì™¸ë¶€ ë£¨í”„: ì„¤ì • ì¬ë¡œë“œë¥¼ ìœ„í•´ ì „ì²´ ë¡œì§ì„ ê°ìŒˆ
    while True:
        # ë£¨í”„ ì‹œì‘ ì§í›„ ì¶”ê°€
        old_sell_done = False  # 5ì¼ ì´ìƒ ë³´ìœ  ì¢…ëª© ë§¤ë„ í”Œë˜ê·¸

        # --- ì„¤ì • íŒŒì¼ì—ì„œ ê°’ ë¡œë“œ ---------------------------------------------------------------------------------------------
        settings = load_settings()

        POOL_COUNT = settings['POOL_COUNT']
        AMOUNT_TO_BUY = settings['AMOUNT_TO_BUY']
        trade_date = get_last_trading_day()
        #trade_date = '20250909'
        MAX_BUY_PRICE = AMOUNT_TO_BUY
        selected_symbols_map = get_all_symbols(p_trade_date=trade_date, p_max_price=MAX_BUY_PRICE, p_pool_count=POOL_COUNT)  # ê¸ˆì¼ ë§¤ìˆ˜ ì¢…ëª© 40
        send_message(f"âœ… [{trade_date}]ì¼ DB ì¡°íšŒ ì™„ë£Œ: {len(selected_symbols_map)}ê±´ ë³€ë™ì„±ëŒíŒŒ ë§¤ìˆ˜í’€ ë°˜í™˜")
        send_message_main(f"âœ… [{trade_date}]ì¼ DB ì¡°íšŒ ì™„ë£Œ: {len(selected_symbols_map)}ê±´ ë³€ë™ì„±ëŒíŒŒ ë§¤ìˆ˜í’€ ë°˜í™˜")

        #selected_symbols_map = {
        #    "005930": "ì‚¼ì„±ì „ì",
        #    "035720": "ì¹´ì¹´ì˜¤",
        #    "000660": "SKí•˜ì´ë‹‰ìŠ¤",
        #    "068270": "ì…€íŠ¸ë¦¬ì˜¨",
        #    "005380": "í˜„ëŒ€ì°¨",
        #    # í•„ìš”ì— ë”°ë¼ ë” ë§ì€ ì¢…ëª©ì„ ì—¬ê¸°ì— ì¶”ê°€í•©ë‹ˆë‹¤.
        #    # "ì¢…ëª©ì½”ë“œ": "ì¢…ëª©ëª…" í˜•ì‹ìœ¼ë¡œ ì¶”ê°€í•˜ì„¸ìš”.
        #}

        ACCOUNT_AMT = settings['ACCOUNT_AMT']    #**************** ACCOUNT_AMT/TARGET_BUY_COUNT/df['ì¢…ê°€'] ëŠ” í•­ìƒ ê°™ì´ ê³ ë ¤ë˜ì•¼ í•¨....
        #--- # --- âœ¨ 09ì‹œ ì´ì „ EXCLUDE_LIST ì´ˆê¸°í™” ë¡œì§ âœ¨ ---
        #--- t_now_check = datetime.now()
        #--- t_9_oclock = t_now_check.replace(hour=9, minute=0, second=0, microsecond=0)
#--- 
        #--- # 09:00:00 ì´ì „ì´ë©´ EXCLUDE_LISTë¥¼ ê°•ì œë¡œ ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¡œ ì„¤ì •
        #--- if t_now_check < t_9_oclock:
        #---     send_message("âœ… 09ì‹œ ì´ì „ì´ë¯€ë¡œ EXCLUDE_LISTë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.")
        #---     EXCLUDE_LIST = []
        #--- else:
        #---     EXCLUDE_LIST = settings['EXCLUDE_LIST']
        EXCLUDE_LIST = settings['EXCLUDE_LIST']
        TARGET_BUY_COUNT = settings['TARGET_BUY_COUNT']

        T_9_TIME = settings['T_9_TIME']
        T_START_TIME = settings['T_START_TIME']
        T_SELL_TIME = settings['T_SELL_TIME']
        T_EXIT_TIME = settings['T_EXIT_TIME']

        #AMOUNT_TO_BUY = settings['AMOUNT_TO_BUY']   #ìœ—ë¶€ë¶„ì—ì„œ ì²˜ë¦¬
        STOP_ADD_LOSE_PCT = settings['STOP_ADD_LOSE_PCT']
        MAX_MOOLING = settings['MAX_MOOLING']

        SLIPPAGE_LIMIT = settings['SLIPPAGE_LIMIT']
        STOP_LOSE_PCT = settings['STOP_LOSE_PCT']
        STOP_TRAILING_REBOUND = settings['STOP_TRAILING_REBOUND']
        STOP_ABS_LOSE_PCT = settings['STOP_ABS_LOSE_PCT']

        BREAK_EVEN_PCT1 = settings['BREAK_EVEN_PCT1']
        BREAK_EVEN_LOSE_PCT1 = settings['BREAK_EVEN_LOSE_PCT1']
        BURN_IN_RATIO = settings['BURN_IN_RATIO']
        BREAK_EVEN_PCT2 = settings['BREAK_EVEN_PCT2']
        BREAK_EVEN_LOSE_PCT2 = settings['BREAK_EVEN_LOSE_PCT2']
        BREAK_EVEN_PCT3 = settings['BREAK_EVEN_PCT3']
        BREAK_EVEN_LOSE_PCT3 = settings['BREAK_EVEN_LOSE_PCT3']
        TAKE_PROFIT_PCT = settings['TAKE_PROFIT_PCT']
        TAKE_PROFIT_LOSE_PCT = settings['TAKE_PROFIT_LOSE_PCT']

        AMOUNT_LIMIT1_TIME = settings['AMOUNT_LIMIT1_TIME']
        AMOUNT_LIMIT1 = settings['AMOUNT_LIMIT1']
        AMOUNT_LIMIT2_TIME = settings['AMOUNT_LIMIT2_TIME']
        AMOUNT_LIMIT2 = settings['AMOUNT_LIMIT2']

        TARGET_K1 = settings['TARGET_K1']
        TARGET_K2_TIME = settings['TARGET_K2_TIME']
        TARGET_K2 = settings['TARGET_K2']
        TARGET_K3_TIME = settings['TARGET_K3_TIME']
        TARGET_K3 = settings['TARGET_K3']

        TOTAL_LOSE_EXIT_PCT = settings['TOTAL_LOSE_EXIT_PCT']
        # --- ì„¤ì • íŒŒì¼ ë¡œë“œ ë ---------------------------------------------------------------------------------------------

        if EXCLUDE_LIST and len(EXCLUDE_LIST) > 0:
            # âœ… ë³€ê²½: ë”•ì…”ë„ˆë¦¬ì—ì„œ ì œì™¸í•  ì¢…ëª©ë“¤ì„ í•„í„°ë§í•˜ì—¬ ìƒˆë¡œìš´ ë”•ì…”ë„ˆë¦¬ ìƒì„±
            selected_symbols_map = {
                sym: name
                for sym, name in selected_symbols_map.items()
                if sym not in EXCLUDE_LIST
            }

        bought_list = [] # ë§¤ìˆ˜ ì™„ë£Œëœ ì¢…ëª© ë¦¬ìŠ¤íŠ¸
        total_cash = get_balance() # ë³´ìœ  í˜„ê¸ˆ ì¡°íšŒ (10,000ì› ì œì™¸)
        if total_cash < 0: # ì”ì•¡ì´ ë§ˆì´ë„ˆìŠ¤ê°€ ë˜ëŠ” ê²½ìš° ë°©ì§€
            total_cash = 0
        stock_dict = get_stock_balance() # ë³´ìœ  ì£¼ì‹ ì¡°íšŒ
        # ACCOUNT_AMT ê³„ì‚°
        total_buy_value = int(sum(
            stock_dict[sym]['í˜„ì¬ìˆ˜ëŸ‰'] * stock_dict[sym]['ë§¤ìˆ˜ê°€']
            for sym in stock_dict
        ))
        ACCOUNT_AMT = total_cash + total_buy_value  # ì´ˆê¸° ê³„ì¢Œ ê¸ˆì•¡ ì„¤ì •
        #send_message(f"ğŸ“‹ í”„ë¡œê·¸ë¨ ì‹œì‘: ACCOUNT_AMT = {ACCOUNT_AMT:,}ì› (í˜„ê¸ˆ: {total_cash:,}ì›, ì£¼ì‹êµ¬ë§¤ê°€ê²©: {total_buy_value:,}ì›)")
        for sym in stock_dict.keys():
            bought_list.append(sym)

        t_now = datetime.now()

        # ì£¼ì‹ ë§¤ìˆ˜/ë§¤ë„ ì‹œê°„
        t_9 = t_now.replace(**T_9_TIME)
        t_start = t_now.replace(**T_START_TIME)

        t_notbuy = t_now.replace(hour=13, minute=30, second=0,microsecond=0)
        t_oldstocksell = t_now.replace(hour=15, minute=0, second=0, microsecond=0)
        t_notstoploss = t_now.replace(hour=15, minute=10, second=0,microsecond=0)
        #t_notbuy = t_now.replace(hour=14, minute=30, second=0,microsecond=0)
        #t_oldstocksell = t_now.replace(hour=16, minute=0, second=0, microsecond=0)
        #t_notstoploss = t_now.replace(hour=16, minute=10, second=0,microsecond=0)

        t_sell = t_now.replace(**T_SELL_TIME)
        t_exit = t_now.replace(**T_EXIT_TIME)

        #---# ì´ë¯¸ ë§¤ìˆ˜í•œ ì¢…ëª© ìˆ˜ë¥¼ ê³ ë ¤í•˜ì—¬ buy_percent ê³„ì‚°
        #---remaining_buy_count = TARGET_BUY_COUNT - len(bought_list)
        #---if remaining_buy_count <= 0:
        #---    buy_percent = 0 # ë” ì´ìƒ ë§¤ìˆ˜í•  ì¢…ëª©ì´ ì—†ìœ¼ë©´ ë¹„ìœ¨ì„ 0ìœ¼ë¡œ ì„¤ì •
        #---else:
        #---    # ì†Œìˆ˜ì  ì…‹ì§¸ ìë¦¬ê¹Œì§€ ìœ ì§€í•˜ê³  ë„·ì§¸ ìë¦¬ë¶€í„° ë²„ë¦¼
        #---    buy_percent = math.floor((100 / remaining_buy_count) * 0.01 * 1000) / 1000
        #---
        #---# ì¢…ëª©ë³„ ì£¼ë¬¸ ê¸ˆì•¡ ì™„í™” ë¡œì§ ì¶”ê°€
        #---if t_now >= t_now.replace(**AMOUNT_LIMIT2_TIME):
        #---    buy_amount = int(total_cash * buy_percent * AMOUNT_LIMIT2)  # ë§¤ìˆ˜ ë¹„ì¤‘ ì¤„ì„
        #---elif t_now >= t_now.replace(**AMOUNT_LIMIT1_TIME):
        #---    buy_amount = int(total_cash * buy_percent * AMOUNT_LIMIT1)  # ë§¤ìˆ˜ ë¹„ì¤‘ ì¤„ì„
        #---else:
        #---    buy_amount = int(total_cash * buy_percent)

        soldout = False

        send_message("ğŸš€ êµ­ë‚´ ì£¼ì‹ ìë™ë§¤ë§¤ í”„ë¡œê·¸ë¨ì„ ì‹œì‘í•©ë‹ˆë‹¤.")
        send_message_main("ğŸš€ êµ­ë‚´ ì£¼ì‹ ìë™ë§¤ë§¤ í”„ë¡œê·¸ë¨ì„ ì‹œì‘í•©ë‹ˆë‹¤.")
        last_stop_loss_check_time = datetime.now() - timedelta(seconds=15) # ì†ì ˆ ì´ˆê¸°ê°’ ì„¤ì • 
        last_profit_taking_check_time = datetime.now() - timedelta(seconds=45) # ìµì ˆ ì´ˆê¸°ê°’ ì„¤ì • 
        last_balance_check_time = datetime.now() - timedelta(minutes=15)  # ì´ˆê¸°í™”: ê³¼ê±°ë¡œ ì„¤ì •í•´ì„œ 15ë¶„í›„ì— ì¶œë ¥ë˜ë„ë¡ ì´í›„ëŠ” 30ë¶„ë§ˆë‹¤
        last_heartbeat = datetime.now() - timedelta(minutes=10)
        last_reload_check_time = datetime.now() - timedelta(seconds=10)
        last_can_buy1_flag_time = datetime.now() - timedelta(minutes=11)
        last_can_buy2_flag_time = datetime.now() - timedelta(minutes=12)
        last_can_buy3_flag_time = datetime.now() - timedelta(minutes=13)
        # ìŠ¬ë¦¬í”¼ì§€ ì´ˆê³¼ ê°ì‹œìš© ë³€ìˆ˜ë“¤ (ì´ˆê¸°í™” ë¶€ë¶„)
        slippage_count = {}
        slippage_last_logged = {}
        # ì¶”ê°€: íœ´ì¼ ì¢…ë£Œ í”Œë˜ê·¸
        program_exit = False
        # âœ¨ ì¶”ê°€: ìµì ˆ ë³€ë™(Trailing Stop)ì„ ìœ„í•œ ë”•ì…”ë„ˆë¦¬
        trailing_peaks = {} 
        # âœ¨ ì¶”ê°€: ì†ì ˆ ë³€ë™(Trailing Stop)ì„ ìœ„í•œ ë”•ì…”ë„ˆë¦¬
        trailing_losses = {}  # ì˜ˆ: {'005930': -1.2}
        blocked_symbols = set()   # ğŸš¨ ë°˜ë“œì‹œ ì´ˆê¸°í™” í•„ìš”

        while True:
            t_now = datetime.now()

            can_buy_flag = can_additional_buy()
            #if not can_buy_flag:
            #    time.sleep(300)   

            # 10ë¶„ë§ˆë‹¤ heartbeat ì¶œë ¥
            if (t_now - last_heartbeat).total_seconds() >= 600:
                send_message("âœ… ì‹œìŠ¤í…œ ì •ìƒ ì‘ë™ ì¤‘ì…ë‹ˆë‹¤.")
                last_heartbeat = t_now

            #today = datetime.today().weekday()
            today = datetime.today()
            if today.weekday() >= 5 or is_holiday(today.strftime("%Y-%m-%d")):  # í† ìš”ì¼/ì¼ìš”ì¼/íœ´ì¼ ì´ë©´ ìë™ ì¢…ë£Œ
                send_message("ğŸ›‘ íœ´ì¼ì´ë¯€ë¡œ í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
                send_message_main("ğŸ›‘ íœ´ì¼ì´ë¯€ë¡œ í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
                program_exit = True # âœ¨ í”Œë˜ê·¸ ì„¤ì • âœ¨
                break

            # --- âœ¨ SettingReload.ini í™•ì¸ ë° ì¬ë¡œë“œ ë¡œì§ âœ¨ ---
            # íŠ¹ì • ì‹œê°„(ì˜ˆ: ë§¤ë¶„ 00ì´ˆ) ë˜ëŠ” ì£¼ê¸°ì ìœ¼ë¡œ ì¬ë¡œë“œ í”Œë˜ê·¸ í™•ì¸
            if (t_now - last_reload_check_time).total_seconds() >= 60: # 60ì´ˆê°€ ì§€ë‚¬ìœ¼ë©´ ìˆ˜í–‰
                if load_reload_setting(): # RELOAD = TRUE ì¸ ê²½ìš°
                    send_message("ğŸ”„ SettingReload.ini RELOAD = TRUE ê°ì§€! ì„¤ì •ì„ ì¬ë¡œë“œí•©ë‹ˆë‹¤.")
                    write_reload_setting(False) # RELOADë¥¼ FALSEë¡œ ë˜ëŒë¦¼
                    break # ë‚´ë¶€ while ë£¨í”„ë¥¼ ì¢…ë£Œí•˜ê³  ì™¸ë¶€ while ë£¨í”„ë¡œ ì´ë™í•˜ì—¬ ì„¤ì • ì¬ë¡œë“œ
                last_reload_check_time = t_now # ì¬ë¡œë“œ ì²´í¬ í›„ ì‹œê°„ ì—…ë°ì´íŠ¸
            # --- âœ¨ ì¬ë¡œë“œ ë¡œì§ ë âœ¨ ---

            if t_9 < t_now < t_start and soldout == False: # # AM 09:00 ~ AM 09:03 : ì”ì—¬ ìˆ˜ëŸ‰ ë§¤ë„
                #~~~ for sym, details in stock_dict.items():
                #~~~     qty = details.get('í˜„ì¬ìˆ˜ëŸ‰', '0') # 'í˜„ì¬ìˆ˜ëŸ‰'ì„ ì¶”ì¶œí•˜ì—¬ qtyì— í• ë‹¹
                #~~~     if int(qty) > 0: # ìˆ˜ëŸ‰ì´ 0ë³´ë‹¤ í° ê²½ìš°ì—ë§Œ ë§¤ë„ ì‹¤í–‰
                #~~~         sell(sym, qty, stock_dict_cache=stock_dict, div="ì¥ì‹œì‘")  # â† ìºì‹œ ì „ë‹¬
                soldout = True
                #~~~ bought_list = []
                #~~~ time.sleep(0.1)
                #~~~ stock_dict = get_stock_balance()

            if t_start < t_now < t_sell:  # AM 09:03 ~ PM 02:58 : ë§¤ìˆ˜     
            
                #send_message("ë£¨í”„ ì‹œì‘..................") #ë£¨í”„ ì‹œê°„ ì¸¡ì •ìš©

                # ë¬¼íƒ€ê¸° ê°ì‹œ ë¡œì§ -------------------------------------------------------  
                if t_notstoploss < t_now < t_sell:  # PM 03:10 ~ PM 03:23 : BREAK_EVEN_PCT ì¡°ì •
                    STOP_LOSE_PCT = -3000.0
                    STOP_TRAILING_REBOUND = 1.0
                    STOP_ABS_LOSE_PCT = -5000.0
                if (t_now - last_stop_loss_check_time).total_seconds() >= 15: # 15ì´ˆë§ˆë‹¤ ì²´í¬
                    if STOP_LOSE_PCT < 0:
                        stopped = check_trailing_stop_loss(
                            stock_dict=stock_dict,
                            trailing_losses=trailing_losses,
                            blocked_symbols=blocked_symbols,   # âœ… setìœ¼ë¡œ ë¯¸ë¦¬ ì„ ì–¸ í•„ìš”
                            stop_loss_threshold=STOP_LOSE_PCT,
                            trailing_rebound=STOP_TRAILING_REBOUND,
                            stop_abs_loss_threshold=STOP_ABS_LOSE_PCT,
                            add_lose_pct=STOP_ADD_LOSE_PCT,
                            max_mooling=MAX_MOOLING
                        )
                        if stopped:
                            if not can_buy_flag:
                                if (t_now - last_can_buy1_flag_time).total_seconds() >= 900:
                                    send_message(f"ğŸš« ë¬¼íƒ€ê¸° ì¤‘ë‹¨: ê³„ì¢Œ ì”ê³  ë¶€ì¡±(<{AMOUNT_TO_BUY:,}ì›)")
                                    send_message_main(f"ğŸš« ë¬¼íƒ€ê¸° ì¤‘ë‹¨: ê³„ì¢Œ ì”ê³  ë¶€ì¡±(<{AMOUNT_TO_BUY:,}ì›)")
                                    last_can_buy1_flag_time = t_now
                            else:
                                for sym in stopped:
                                    remaining_buy_count = 100   # TARGET_BUY_COUNT - len(bought_list)
                                    if remaining_buy_count > 0:
                                        current_price = get_current_price(sym)
                                        info = stock_dict.get(sym, {})
                                        if current_price is None or not info:
                                            continue

                                        bought_name = info.get('ì¢…ëª©ëª…')
                                        bought_qty = info.get('í˜„ì¬ìˆ˜ëŸ‰', 0)
                                        bought_price = info.get('ë§¤ìˆ˜ê°€')

                                        total_cash = get_balance()
                                        buy_percent = math.floor((100 / remaining_buy_count) * 0.01 * 1000) / 1000

                                        # ì¢…ëª©ë³„ ì£¼ë¬¸ ê¸ˆì•¡ ì™„í™” ë¡œì§ ì¶”ê°€
                                        if t_now >= t_now.replace(**AMOUNT_LIMIT2_TIME):
                                            buy_amount = int(total_cash * buy_percent * AMOUNT_LIMIT2)  # ë§¤ìˆ˜ ë¹„ì¤‘ ì¤„ì„
                                        elif t_now >= t_now.replace(**AMOUNT_LIMIT1_TIME):
                                            buy_amount = int(total_cash * buy_percent * AMOUNT_LIMIT1)  # ë§¤ìˆ˜ ë¹„ì¤‘ ì¤„ì„
                                        else:
                                            buy_amount = int(total_cash * buy_percent)
                                        
                                        if AMOUNT_TO_BUY > 0:
                                            buy_amount = AMOUNT_TO_BUY
                                        #buy_qty = int(buy_amount // current_price)
                                        if buy_amount > 0:
                                            send_message(f"ğŸ’§ {bought_name}({sym}) ì†ì ˆ ëŒ€ì‹  ì¶”ê°€ ë¬¼íƒ€ê¸° ì§„í–‰ ({buy_amount:,}ì›)")
                                            send_message_main(f"ğŸ’§ {bought_name}({sym}) ì†ì ˆ ëŒ€ì‹  ì¶”ê°€ ë¬¼íƒ€ê¸° ì§„í–‰ ({buy_amount:,}ì›)")
                                            result = safe_buy(sym, buy_amount, current_price, stock_name=bought_name)
                                            if result:
                                                soldout = False

                                                if sym in trailing_losses:
                                                    trailing_losses.pop(sym, None)
                                                if sym in trailing_peaks:
                                                    trailing_peaks.pop(sym, None)
                                                                            
                                                time.sleep(0.1)
                                                bought_list = []
                                                stock_dict = get_stock_balance() # ë³´ìœ  ì£¼ì‹ ì¡°íšŒ
                                                for sym in stock_dict.keys():
                                                    bought_list.append(sym)

                    last_stop_loss_check_time = t_now # ë§ˆì§€ë§‰ ì²´í¬ ì‹œê°„ ì—…ë°ì´íŠ¸
                # ë¬¼íƒ€ê¸° ê°ì‹œ ë¡œì§ ë ------------------------------------------------------------------
                # ìµì ˆ ê°ì‹œ ë¡œì§ -----------------------------------------------------------                
                if t_notbuy < t_now < t_sell:  # PM 01:30 ~ PM 03:23 : BREAK_EVEN_PCT ì¡°ì •
                    BREAK_EVEN_PCT1 = 3.0
                    BREAK_EVEN_LOSE_PCT1 = 0.3
                    BREAK_EVEN_PCT2 = 5.0
                    BREAK_EVEN_LOSE_PCT2 = 0.3
                    BREAK_EVEN_PCT3 = 7.0
                    BREAK_EVEN_LOSE_PCT3 = 0.3
                    TAKE_PROFIT_PCT = 9.0
                    TAKE_PROFIT_LOSE_PCT = 0.3
                if (t_now - last_profit_taking_check_time).total_seconds() >= 15: # 15ì´ˆë§ˆë‹¤ ì²´í¬
                    profited_flag = 0
                    burn_in_list_flag = 0
                    if BREAK_EVEN_PCT1 > 0:
                        profited, burn_in_list = check_profit_taking_with_trailing_stop(
                            stock_dict=stock_dict,
                            trailing_peak_prices=trailing_peaks,
                            break_even_pct1=BREAK_EVEN_PCT1,
                            break_even_lose_pct1=BREAK_EVEN_LOSE_PCT1,
                            break_even_pct2=BREAK_EVEN_PCT2,
                            break_even_lose_pct2=BREAK_EVEN_LOSE_PCT2,
                            break_even_pct3=BREAK_EVEN_PCT3,
                            break_even_lose_pct3=BREAK_EVEN_LOSE_PCT3,
                            take_profit_pct=TAKE_PROFIT_PCT,
                            take_profit_lose_pct=TAKE_PROFIT_LOSE_PCT
                        )
                        if profited:
                            profited_flag = 1
                            for sym in profited:
                                qty = stock_dict.get(sym, {}).get('í˜„ì¬ìˆ˜ëŸ‰', 0)
                                if qty > 0:
                                    result = sell(sym, qty, stock_dict_cache=stock_dict, div="ìµì ˆ")  # â† ìºì‹œ ì „ë‹¬
                                    if result:
                                        if sym in bought_list:
                                            bought_list.remove(sym)
                                        # âœ… ë³€ê²½: selected_symbols_mapì—ì„œ í•´ë‹¹ ì¢…ëª© ì œê±°
                                        if sym in selected_symbols_map:
                                            selected_symbols_map.pop(sym, None)
                                        if sym in trailing_peaks:
                                            trailing_peaks.pop(sym, None)
                                        if sym in trailing_losses:
                                            trailing_losses.pop(sym, None)
                        if BURN_IN_RATIO > 0:
                            if burn_in_list:
                                if not can_buy_flag:
                                    if (t_now - last_can_buy2_flag_time).total_seconds() >= 900:
                                        send_message(f"ğŸš« ë¶ˆíƒ€ê¸° ì¤‘ë‹¨: ê³„ì¢Œ ì”ê³  ë¶€ì¡±(<{AMOUNT_TO_BUY:,}ì›)")
                                        send_message_main(f"ğŸš« ë¶ˆíƒ€ê¸° ì¤‘ë‹¨: ê³„ì¢Œ ì”ê³  ë¶€ì¡±(<{AMOUNT_TO_BUY:,}ì›)")
                                        last_can_buy2_flag_time = t_now
                                else:
                                    burn_in_list_flag = 1
                                    for sym in burn_in_list:
                                        ratio = BURN_IN_RATIO
                                        current_price = get_current_price(sym)
                                        info = stock_dict.get(sym, {})
                                        if current_price is None or not info:
                                            continue

                                        bought_name = info.get('ì¢…ëª©ëª…')
                                        bought_qty = info.get('í˜„ì¬ìˆ˜ëŸ‰', 0)
                                        bought_price = info.get('ë§¤ìˆ˜ê°€')

                                        if bought_price and bought_qty:
                                            invested = bought_price * bought_qty
                                            amount_to_buy = int(invested * ratio)
                                            #qty_to_buy = int(amount_to_buy // current_price)
                                            if amount_to_buy > 0:
                                                send_message(f"ğŸ”¥ {bought_name}({sym}) ë¶ˆíƒ€ê¸° ë§¤ìˆ˜ ì§„í–‰ ({ratio*100:.1f}%, {amount_to_buy:,}ì›)")
                                                send_message_main(f"ğŸ”¥ {bought_name}({sym}) ë¶ˆíƒ€ê¸° ë§¤ìˆ˜ ì§„í–‰ ({ratio*100:.1f}%, {amount_to_buy:,}ì›)")
                                                result = safe_buy(sym, amount_to_buy, current_price, stock_name=bought_name)
                                                if result:
                                                    soldout = False
                        if profited_flag > 0 or burn_in_list_flag > 0:
                            time.sleep(0.1)
                            bought_list = []
                            stock_dict = get_stock_balance() # ë³´ìœ  ì£¼ì‹ ì¡°íšŒ
                            for sym in stock_dict.keys():
                                bought_list.append(sym)

                            #---# âœ¨ ìµì ˆ í›„ buy_amount ì¬ê³„ì‚° ë¡œì§
                            #---time.sleep(5) # ê¸‰ê²©í•œ ì¬ë§¤ìˆ˜ ë°©ì§€ìš©
                            #---remaining_buy_count = TARGET_BUY_COUNT - len(bought_list)
                            #---if remaining_buy_count > 0:
                            #---    buy_percent = math.floor((100 / remaining_buy_count) * 0.01 * 1000) / 1000
                            #---    total_cash = get_balance() - 10000
                            #---    if total_cash < 0:
                            #---        total_cash = 0
                            #---    # ì¢…ëª©ë³„ ì£¼ë¬¸ ê¸ˆì•¡ ì™„í™” ë¡œì§ ì¶”ê°€
                            #---    if t_now >= t_now.replace(**AMOUNT_LIMIT2_TIME):
                            #---        buy_amount = int(total_cash * buy_percent * AMOUNT_LIMIT2)  # ë§¤ìˆ˜ ë¹„ì¤‘ ì¤„ì„
                            #---    elif t_now >= t_now.replace(**AMOUNT_LIMIT1_TIME):
                            #---        buy_amount = int(total_cash * buy_percent * AMOUNT_LIMIT1)  # ë§¤ìˆ˜ ë¹„ì¤‘ ì¤„ì„
                            #---    else:
                            #---        buy_amount = int(total_cash * buy_percent)
                            #---else:
                            #---    buy_amount = 0
                    
                    last_profit_taking_check_time = t_now # ë§ˆì§€ë§‰ ì²´í¬ ì‹œê°„ ì—…ë°ì´íŠ¸
                # ìµì ˆ ê°ì‹œ ë¡œì§ ë -------------------------------------------------------------





                if t_start < t_now < t_notbuy:  # AM 09:03 ~ PM 02:30 : ë§¤ìˆ˜, ì´ì‹œê°„ ì´í›„ì—ëŠ” ë§¤ìˆ˜ê¸ˆì§€ 





                    # âœ… ë³€ê²½: ë”•ì…”ë„ˆë¦¬ì˜ (í‚¤, ê°’)ì„ ìˆœíšŒí•˜ë©° ì¢…ëª©ì½”ë“œ(sym)ì™€ ì¢…ëª©ëª…(stock_name)ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
                    for sym, stock_name in list(selected_symbols_map.items()):
                        remaining_buy_count = TARGET_BUY_COUNT - len(bought_list)
                        if remaining_buy_count > 1:
                            if sym in bought_list:
                                selected_symbols_map.pop(sym, None)
                                continue

                            # ğŸ” kê°’ ì ì§„ì  ì™„í™” ë¡œì§ ì¶”ê°€
                            if remaining_buy_count > 1:
                                if t_now >= t_now.replace(**TARGET_K3_TIME):
                                    k = TARGET_K3
                                elif t_now >= t_now.replace(**TARGET_K2_TIME):
                                    k = TARGET_K2
                                else:
                                    k = TARGET_K1
                            else:
                                k = TARGET_K1

                            target_price, open_price = get_price_info(sym, k, 0.05, stock_name)
                            #time.sleep(0.1)
                            current_price = get_current_price(sym)
                            if open_price is None or target_price is None or current_price is None: # ê°€ê²©ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìœ¼ë©´ ë‹¤ìŒ ì¢…ëª©ìœ¼ë¡œ ë„˜ì–´ê°
                                send_message(f"[{sym}]{stock_name} ê°­ìƒìŠ¹/ê°­í•˜ë½/ê°€ê²©ìˆ˜ì‹ ì‹¤íŒ¨. ë‹¤ìŒ ì¢…ëª©ìœ¼ë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.")
                                #time.sleep(1) # API í˜¸ì¶œ ë¹ˆë„ ì¡°ì ˆ
                                continue 

                            # ê°­ìƒìŠ¹ ì œì™¸í•˜ê³ , ì§„ì§œ ì¥ì¤‘ ëŒíŒŒë§Œ ë§¤ìˆ˜
                            if open_price < target_price < current_price:
                            # ê°­ìƒìŠ¹(or NXT) í¬í•¨í•´ì„œ target_price ëŒíŒŒ ë§¤ìˆ˜
                            #if target_price < current_price:
                                # âœ… ë³€ê²½: stock_nameì€ ì´ë¯¸ for ë£¨í”„ì—ì„œ ê°€ì ¸ì™”ìœ¼ë¯€ë¡œ ì´ ì¤„ì€ í•„ìš” ì—†ìŠµë‹ˆë‹¤.
                                # stock_name = symbol_name_map.get(sym, "Unknown") 

                                # ëŒíŒŒ ì¡°ê±´ì€ ë§Œì¡±í–ˆì§€ë§Œ ìŠ¬ë¦¬í”¼ì§€ ì²´í¬
                                if current_price > target_price * SLIPPAGE_LIMIT:
                                    # ìŠ¬ë¦¬í”¼ì§€ íšŸìˆ˜ ê¸°ë¡
                                    if sym not in slippage_count:
                                        slippage_count[sym] = 1
                                    else:
                                        slippage_count[sym] += 1
                                    # 3íšŒ ì´í•˜ê¹Œì§€ëŠ” ë¬´ì¡°ê±´ ì¶œë ¥
                                    if slippage_count[sym] <= 3:
                                        send_message(f"ğŸ”„ {stock_name}({sym}) ìŠ¬ë¦¬í”¼ì§€ ì´ˆê³¼ {slippage_count[sym]}íšŒ (í˜„ì¬ê°€:{current_price:.2f} > í—ˆìš©ê°€:{target_price * SLIPPAGE_LIMIT:.2f})")
                                    else:
                                        # ë§ˆì§€ë§‰ìœ¼ë¡œ ì¶œë ¥í•œ ì‹œê°„ì´ 10ë¶„ ì§€ë‚¬ìœ¼ë©´ ë‹¤ì‹œ ì¶œë ¥
                                        last_log_time = slippage_last_logged.get(sym)
                                        if last_log_time is None or (t_now - last_log_time).total_seconds() >= 600:
                                            send_message(f"ğŸ”„ {stock_name}({sym}) ìŠ¬ë¦¬í”¼ì§€ ë°˜ë³µ ì´ˆê³¼ ì¤‘... (í˜„ì¬ê°€:{current_price:.2f} > í—ˆìš©ê°€:{target_price * SLIPPAGE_LIMIT:.2f})")
                                            slippage_last_logged[sym] = t_now
                                    continue  # ìŠ¬ë¦¬í”¼ì§€ ì´ˆê³¼ ì¢…ëª©ì€ ë§¤ìˆ˜í•˜ì§€ ì•ŠìŒ
                                else:
                                    #buy_qty = 0  # ë§¤ìˆ˜í•  ìˆ˜ëŸ‰ ì´ˆê¸°í™”  
                                    total_cash = get_balance()
                                    buy_percent = math.floor((100 / remaining_buy_count) * 0.01 * 1000) / 1000

                                    # ì¢…ëª©ë³„ ì£¼ë¬¸ ê¸ˆì•¡ ì™„í™” ë¡œì§ ì¶”ê°€
                                    if t_now >= t_now.replace(**AMOUNT_LIMIT2_TIME):
                                        buy_amount = int(total_cash * buy_percent * AMOUNT_LIMIT2)  # ë§¤ìˆ˜ ë¹„ì¤‘ ì¤„ì„
                                    elif t_now >= t_now.replace(**AMOUNT_LIMIT1_TIME):
                                        buy_amount = int(total_cash * buy_percent * AMOUNT_LIMIT1)  # ë§¤ìˆ˜ ë¹„ì¤‘ ì¤„ì„
                                    else:
                                        buy_amount = int(total_cash * buy_percent)
                                    if AMOUNT_TO_BUY > 0:
                                        buy_amount = AMOUNT_TO_BUY

                                    #buy_qty = int(buy_amount // current_price)
                                    if buy_amount > 0:
                                        send_message(f"ğŸ“ˆ {stock_name}({sym}) ëª©í‘œê°€ ë‹¬ì„±({target_price} < {current_price}) ë§¤ìˆ˜ë¥¼ ì‹œë„í•©ë‹ˆë‹¤.")
                                        send_message_main(f"ğŸ“ˆ {stock_name}({sym}) ëª©í‘œê°€ ë‹¬ì„±({target_price} < {current_price}) ë§¤ìˆ˜ë¥¼ ì‹œë„í•©ë‹ˆë‹¤.")
                                        result = safe_buy(sym, buy_amount, current_price, stock_name)
                                        if result:
                                            soldout = False
                                            time.sleep(0.1)
                                            bought_list = []
                                            stock_dict = get_stock_balance() # ë³´ìœ  ì£¼ì‹ ì¡°íšŒ
                                            for sym in stock_dict.keys():
                                                bought_list.append(sym)
                            time.sleep(0.025)
                    time.sleep(0.025)





                # âœ… 10ë¶„ë§ˆë‹¤ ì”ê³  í™•ì¸ (ì˜ˆ: 09:15, 09:25, 09:35 ...), HTSì—ì„œ ì§ì ‘ ë§¤ìˆ˜/ë§¤ë„ ì¢…ëª© ìµœì‹ í™”
                if (t_now - last_balance_check_time).total_seconds() >= 600:  # 1800ì´ˆ = 30ë¶„
                    bought_list = []
                    stock_dict = get_stock_balance() # ë³´ìœ  ì£¼ì‹ ì¡°íšŒ
                    for sym in stock_dict.keys():
                        bought_list.append(sym)
                    # âœ¨ ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬ ë¡œì§ ì¶”ê°€ âœ¨
                    if stock_dict:
                        total_cash = get_balance()  # í˜„ê¸ˆ ì”ê³  ì¡°íšŒ (10,000ì› ì œì™¸)
                        if total_cash < 0:
                            total_cash = 0
                        # ë³´ìœ  ì£¼ì‹ì˜ í˜„ì¬ í‰ê°€ ê¸ˆì•¡ ê³„ì‚°
                        total_stock_value = int(sum(
                            stock_dict[sym]['í˜„ì¬ìˆ˜ëŸ‰'] * get_current_price(sym) 
                            for sym in stock_dict 
                            if get_current_price(sym) is not None
                        ))
                        # ê³„ì¢Œ ì „ì²´ ê¸ˆì•¡ = í˜„ê¸ˆ + ì£¼ì‹ í‰ê°€ ê¸ˆì•¡
                        total_account_value = total_cash + total_stock_value
                        # ì´ˆê¸° ê³„ì¢Œ ê¸ˆì•¡ ëŒ€ë¹„ ì†ì‹¤ë¥  ê³„ì‚°
                        loss_pct = ((total_account_value - ACCOUNT_AMT) / ACCOUNT_AMT) * 100
                        if loss_pct <= TOTAL_LOSE_EXIT_PCT:
                            send_message(f"ğŸš¨ ê³„ì¢Œ ì „ì²´ ê¸ˆì•¡ ì†ì‹¤ í•œë„({TOTAL_LOSE_EXIT_PCT}%) ë„ë‹¬! í˜„ì¬ ì†ì‹¤ë¥ : {loss_pct:.2f}% | ë³´ìœ  ì£¼ì‹ ì „ëŸ‰ ë§¤ë„ í›„ í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
                            send_message_main(f"ğŸš¨ ê³„ì¢Œ ì „ì²´ ê¸ˆì•¡ ì†ì‹¤ í•œë„({TOTAL_LOSE_EXIT_PCT}%) ë„ë‹¬! í˜„ì¬ ì†ì‹¤ë¥ : {loss_pct:.2f}% | ë³´ìœ  ì£¼ì‹ ì „ëŸ‰ ë§¤ë„ í›„ í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
                            # ë³´ìœ  ì£¼ì‹ ì „ëŸ‰ ë§¤ë„
                            #~~~ for sym, details in stock_dict.items():
                            #~~~     qty = details.get('í˜„ì¬ìˆ˜ëŸ‰', '0')
                            #~~~     if int(qty) > 0:
                            #~~~         sell(sym, qty, stock_dict_cache=stock_dict, div="ì†ì‹¤í•œë„ì´ˆê³¼")  # â† ìºì‹œ ì „ë‹¬
                            #~~~         time.sleep(1)
                            soldout = True
                            #~~~ bought_list = []
                            program_exit = True # âœ¨ í”Œë˜ê·¸ ì„¤ì • âœ¨
                            break  # ë‚´ë¶€ ë£¨í”„ ì¢…ë£Œ
                    last_balance_check_time = t_now

                #send_message("ë£¨í”„ ë..................") #ë£¨í”„ ì‹œê°„ ì¸¡ì •ìš©

            # ë£¨í”„ ë‚´ë¶€, t_sell < t_now < t_exit ì§ì „ì— ì¶”ê°€
            if not old_sell_done and t_oldstocksell < t_now < t_sell:
                old_syms = get_old_symbols(days=1095)
                if old_syms:
                    send_message(f"â° 1095ì¼ ì´ìƒ ë³´ìœ  ì¢…ëª© ë§¤ë„ ì‹¤í–‰: {len(old_syms)}ê°œ")
                    send_message_main(f"â° 1095ì¼ ì´ìƒ ë³´ìœ  ì¢…ëª© ë§¤ë„ ì‹¤í–‰: {len(old_syms)}ê°œ")
                    for sym, stock_name in old_syms:
                        qty = stock_dict.get(sym, {}).get('í˜„ì¬ìˆ˜ëŸ‰', 0)
                        if qty and int(qty) > 0:
                            result = sell(sym, qty, stock_dict_cache=stock_dict, div="ë³´ìœ ê¸°ê°„ì´ˆê³¼")  # â† ìºì‹œ ì „ë‹¬
                            time.sleep(1)
                            if result:
                                send_message(f"ğŸ“‰ {stock_name}({sym}) ë³´ìœ  1095ì¼ ê²½ê³¼ â†’ ì „ëŸ‰ ë§¤ë„ ì™„ë£Œ")
                                send_message_main(f"ğŸ“‰ {stock_name}({sym}) ë³´ìœ  1095ì¼ ê²½ê³¼ â†’ ì „ëŸ‰ ë§¤ë„ ì™„ë£Œ")
                # âœ… ë§¤ë„ ì§í›„ ë³´ìœ  ìµœì‹ í™”
                bought_list = []
                stock_dict = get_stock_balance() # ë³´ìœ  ì£¼ì‹ ì¡°íšŒ
                for sym in stock_dict.keys():
                    bought_list.append(sym)
                old_sell_done = True

            if t_sell < t_now < t_exit:  # PM 02:58 ~ PM 03:03 : ì¼ê´„ ë§¤ë„
                if soldout == False:
                    #~~~ stock_dict = get_stock_balance()
                    #~~~ for sym, details in stock_dict.items():
                    #~~~     qty = details.get('í˜„ì¬ìˆ˜ëŸ‰', '0') # 'í˜„ì¬ìˆ˜ëŸ‰'ì„ ì¶”ì¶œí•˜ì—¬ qtyì— í• ë‹¹
                    #~~~     if int(qty) > 0: # ìˆ˜ëŸ‰ì´ 0ë³´ë‹¤ í° ê²½ìš°ì—ë§Œ ë§¤ë„ ì‹¤í–‰
                    #~~~         sell(sym, qty, stock_dict_cache=stock_dict, div="ì¥ì¢…ë£Œ")  # â† ìºì‹œ ì „ë‹¬
                    #~~~         time.sleep(1)
                    soldout = True
                    #~~~ bought_list = []
                    time.sleep(1)
            if t_exit < t_now:  # PM 03:03 ~ :í”„ë¡œê·¸ë¨ ì¢…ë£Œ
                send_message("ì¢…ë£Œì‹œì  ë³´ìœ ì£¼ì‹ ì¡°íšŒë‚´ì—­ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤.")
                get_stock_balance()
                print_today_sell_history()  # âœ¨ ì˜¤ëŠ˜ ë§¤ë„ ë‚´ì—­ ì¶œë ¥                
                print_month_sell_history()   # âœ¨ ì´ë²ˆë‹¬ ë§¤ë„ ë‚´ì—­ ì¶œë ¥
                print_year_sell_history()   # âœ¨ ì´ë²ˆí•´ ë§¤ë„ ë‚´ì—­ ì¶œë ¥
                send_message("ğŸ›‘ ìš´ì˜ì‹œê°„ì´ ì•„ë‹ˆë¯€ë¡œ í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
                send_message_main("ğŸ›‘ ìš´ì˜ì‹œê°„ì´ ì•„ë‹ˆë¯€ë¡œ í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
                break

        # ë‚´ë¶€ ë£¨í”„ê°€ breakë¡œ ì¢…ë£Œë˜ì—ˆì„ ë•Œ ì²˜ë¦¬
        if program_exit: # âœ¨ í”Œë˜ê·¸ í™•ì¸ âœ¨
            break # ì™¸ë¶€ ë£¨í”„ë„ ì¢…ë£Œí•˜ì—¬ í”„ë¡œê·¸ë¨ ì™„ì „íˆ ëëƒ„
        elif t_exit > t_now: # í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹œê°„ì´ ì•„ë‹Œë° break ë˜ì—ˆë‹¤ë©´ (ì¦‰, ì¬ë¡œë“œ ë•Œë¬¸)
            send_message("ğŸ› ï¸ ì„¤ì • ì¬ë¡œë“œë¥¼ ìœ„í•´ ë©”ì¸ ë£¨í”„ë¥¼ ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤.")
            send_message_main("ğŸ› ï¸ ì„¤ì • ì¬ë¡œë“œë¥¼ ìœ„í•´ ë©”ì¸ ë£¨í”„ë¥¼ ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤.")
            continue # ì™¸ë¶€ while True ë£¨í”„ì˜ ë‹¤ìŒ ë°˜ë³µìœ¼ë¡œ ì´ë™
        else: # í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹œê°„ì´ë¼ë©´ ì™¸ë¶€ ë£¨í”„ë„ ì¢…ë£Œ
            break

except Exception as e:
    send_message(f"[ì˜¤ë¥˜ ë°œìƒ]{e}")
    time.sleep(1)

#-- ë””ë²„ê·¸ í•„ìš”ì‹œ -- except Exception as e:
#-- ë””ë²„ê·¸ í•„ìš”ì‹œ --     import traceback
#-- ë””ë²„ê·¸ í•„ìš”ì‹œ --     error_msg = f"[ì˜¤ë¥˜ ë°œìƒ] {e}\n{traceback.format_exc()}"
#-- ë””ë²„ê·¸ í•„ìš”ì‹œ --     send_message(error_msg)
#-- ë””ë²„ê·¸ í•„ìš”ì‹œ --     print(error_msg)
#-- ë””ë²„ê·¸ í•„ìš”ì‹œ --     time.sleep(1)
