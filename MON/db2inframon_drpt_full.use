alias taildb2mon='tail -100f ~/IFR/MONITOR/LOG_PERL_D/`date +%Y%m`/db2inframon_`date +%Y%m%d`.log'

cat > db2inframon.sh
#!/usr/bin/ksh

#### init
export TERM=ansi
export LANG=C
export DB2CODEPAGE=1208
. ~db2i115/sqllib/db2profile
cd /work3/db2/V11.5.dc_inshome/jhkim/MONITOR

#### db2 monitor
cnt=0; rr=0; while true
do
perl ./db2inframon_apinfo.pl -d mydb -s 0 -q 10000000 -w 1000000 -e 10000000 -t 0 -a 0 -p 0 -o ./LOG_PERL_D -z -x -c
cnt=`expr $cnt + 1`
sleep 5

if [ `expr $cnt % 60` -eq 0 ];
then
#        perl ./db2inframon_apinfo.pl -d mydb -s 0 -q 10000000 -w 1000000 -e 10000000 -t 5 -a 0 -p 0 -o ./LOG_PERL -z -x -c -O
        perl ./db2inframon_apinfo.pl -d mydb -s 0 -q 10000000 -w 1000000 -e 10000000 -t 0 -a 0 -p 0 -o ./LOG_PERL -z -x -c -O
        #sleep 5
        if [ `expr $cnt % 120` -eq 0 ];
        then
                if [ $rr -eq 0 ];
                then
#                        perl ./inframon_drpt_full.pl -c 6 -u 3 -t 5 -x ./package.sh -y ./package.sh -n ./package_header.sh -l ./package_log.sh -q 2 -e -o ./LOG_PERL
                        rr=1
                else
#                        perl ./inframon_drpt_full.pl -c 6 -u 3 -t 5 -x ./package.sh -y ./package.sh -n ./package_header.sh -l ./package_log.sh -q 2 -o ./LOG_PERL
                        rr=0
                fi

                #sleep 5
                cnt=0
        fi
        sleep 5
fi
done

#### reset




cat > package.sh
db2 connect to sample > /dev/null
db2 -x "select executable_id, num_exec_with_metrics, rows_read, total_cpu_time, stmt_exec_time, rows_modified, lock_waits 
from table(mon_get_pkg_cache_stmt(null,null,'<modified_within>20</modified_within>',-2))"



cat > package_header.sh
perl -e '
printf "%66s%25s%25s%25s%25s%25s%25s\n", "exec_id","num_exec","rows_read","total_cpu","exec_time","rows_modified","lock_waits";
'



cat > package_log.sh
db2 connect to sample > /dev/null
echo -e "\n!! $1 [ $2 ] !!" >> $3
db2 "select varchar(object_type,10) type,varchar(object_schema,10) schema,varchar(object_module,10) module,varchar(object_name,30) name from table(mon_get_section_object($1,null,null,null,null,-2)) with ur" >> $3 2>&1
db2 "call explain_from_section ($1, 'M', null, 0, null, ?, ?, ?, ?, ?)" > /dev/null 2>&1
db2 -x "select max(explain_time) from systools.explain_statement with ur" >> $3 2>/dev/null
#db2exfmt -d sample -1 >> $3 2>/dev/null
##db2exfmt -d sample -e % -n % -s % -v % -w '2020-06-20-15.24.30.860389' '-#' 0 -o fmt
##db2 "select statement_text from systools.explain_statement where explain_time = '2020-06-20-15.24.30.860389'"



************************* table anal
cat db2inframon_20200130.log | grep "Tab_Rows_rw " |perl -MData::Dumper -ane '
@roww = split(/:/,$F[4]);
if($seen{$F[2]}) {
 $cnt = $seen{$F[2]}->[0] + 1;
 $seen{$F[2]}->[0] = $cnt; #seen cnt
 $seen{$F[2]}->[1] = ($seen{$F[2]}->[1] + $roww[0]); #read
 $seen{$F[2]}->[2] = ($seen{$F[2]}->[2] + $roww[1]); #write
 $seen{$F[2]}->[3] = ($seen{$F[2]}->[3] + $roww[2]); #tbscan
 $seen{$F[2]}->[4] = ($seen{$F[2]}->[4] + $roww[3]); #query, data/lob/index/pcnt
 $seen{$F[2]}->[9] = ($seen{$F[2]}->[9] + $roww[8]); #lock escal
 $seen{$F[2]}->[10] = ($seen{$F[2]}->[10] + $roww[9]); #lock wait
 }
else { $seen{$F[2]} = [(1,@roww)] }
END{
 foreach $key (keys %seen) {
 $seen{$key}->[1] = int($seen{$key}->[1] / $seen{$key}->[0]);
 $seen{$key}->[2] = int($seen{$key}->[2] / $seen{$key}->[0]);
 $seen{$key}->[3] = int($seen{$key}->[3] / $seen{$key}->[0]);
 $seen{$key}->[4] = int($seen{$key}->[4] / $seen{$key}->[0]);
 if($seen{$key}->[4] == 0) { $qcnt = 1 } else { $qcnt = $seen{$key}->[4] }
 $seen{$key}->[11] = int($seen{$key}->[1] / $qcnt); #read per query

 $seen{$key}->[9] = int($seen{$key}->[9] / $seen{$key}->[0]);
 $seen{$key}->[10] = int($seen{$key}->[10] / $seen{$key}->[0]);
 
 print "$key $seen{$key}->[0] $seen{$key}->[1] $seen{$key}->[2] $seen{$key}->[3] $seen{$key}->[4] $seen{$key}->[5] $seen{$key}->[6] $seen{$key}->[7] $seen{$key}->[8] $seen{$key}->[9] $seen{$key}->[10] $seen{$key}->[11]\n";
 }
}
' |sort -k2 -n

************************* trans anal
cat db2inframon_20200226.log | grep "Trans " |perl -MData::Dumper -ane '
@roww = ($F[2],$F[4],$F[5],$F[6],$F[7]);
if($seen{$F[1]}) {
 $cnt = $seen{$F[1]}->[0] + 1;
 $seen{$F[1]}->[0] = $cnt; #seen cnt
 $seen{$F[1]}->[1] = ($seen{$F[1]}->[1] + $roww[0]); #trans
 $seen{$F[1]}->[2] = ($seen{$F[1]}->[2] + $roww[1]); #commit
 $seen{$F[1]}->[3] = ($seen{$F[1]}->[3] + $roww[2]); #intcomm
 $seen{$F[1]}->[4] = ($seen{$F[1]}->[4] + $roww[3]); #rollback
 $seen{$F[1]}->[5] = ($seen{$F[1]}->[5] + $roww[4]); #introll
 }
else { $seen{$F[1]} = [(1,@roww)] }
END{
 foreach $key (keys %seen) {
 $seen{$key}->[1] = int($seen{$key}->[1] / $seen{$key}->[0]);
 $seen{$key}->[2] = int($seen{$key}->[2] / $seen{$key}->[0]);
 $seen{$key}->[3] = int($seen{$key}->[3] / $seen{$key}->[0]);
 $seen{$key}->[4] = int($seen{$key}->[4] / $seen{$key}->[0]);
 $seen{$key}->[5] = int($seen{$key}->[5] / $seen{$key}->[0]);
 
 print "$key $seen{$key}->[0] $seen{$key}->[1] $seen{$key}->[2] $seen{$key}->[3] $seen{$key}->[4] $seen{$key}->[5]\n";
 }
}
'

************************* archive log count anal
find ~/IFR/MONITOR/LOG_PERL -name "db2inframon_????????.log_logs" -mtime -28 |sort |xargs grep -Ee "Method 1 Next Log to Archive" |perl -ane '
push(@ars, $F[-1]);
END { 
$ar1 = $ars[0];
$ar2 = $ars[-1];
$diff = $ar2 - $ar1;
print "F: $ar1 -- E: $ar2 -- Diff: $diff \n";
}
'


############################## infra db2 mon start #########################################
1 * * * * sh ~/IFR/MONITOR/infradb2mon_check.sh > ~/IFR/MONITOR/infradb2mon_check.log 2>&1
############################## infra db2 mon end ###########################################

$ cat > ~/IFR/MONITOR/infradb2mon_check.sh
#!/usr/bin/sh
export LANG=C
export TERM=vt100
perl ~/IFR/MONITOR/infradb2mon_check.pl

$ cat > ~/IFR/MONITOR/infradb2mon_check.pl
system("ps -ef | grep db2inframon.sh | grep -v grep");
$ret = $?;
if($ret != 0) {
system("nohup sh ~/IFR/MONITOR/db2inframon.sh > ~/IFR/MONITOR/db2inframon.sh.log 2>&1 &");
$restartdate = localtime;
print "$restartdate --> restart \n";
}


